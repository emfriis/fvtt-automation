{
  "name": "Maneuvers: Menacing Attack",
  "type": "feat",
  "img": "systems/dnd5e/icons/skills/yellow_37.jpg",
  "data": {
    "description": {
      "value": "<p>When you hit a creature with a weapon attack, you can expend one superiority die to attempt to frighten the target. You add the superiority die to the attackâ€™s damage roll, and the target must make a Wisdom saving throw. On a failed save, it is frightened of you until the end of your next turn.</p>",
      "chat": "",
      "unidentified": ""
    },
    "source": "PHB",
    "activation": {
      "type": "none",
      "cost": null,
      "condition": ""
    },
    "duration": {
      "value": null,
      "units": ""
    },
    "target": {
      "value": null,
      "width": null,
      "units": "",
      "type": "self"
    },
    "range": {
      "value": null,
      "long": null,
      "units": ""
    },
    "uses": {
      "value": null,
      "max": "",
      "per": ""
    },
    "consume": {
      "type": "attribute",
      "target": "",
      "amount": 1
    },
    "ability": "",
    "actionType": "util",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": ""
    },
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell"
    },
    "requirements": "Fighter 3",
    "recharge": {
      "value": null,
      "charged": false
    },
    "attunement": 0
  },
  "effects": [
    {
      "_id": "rnVwO5B1LworJCtY",
      "changes": [
        {
          "key": "flags.dnd5e.DamageBonusMacro",
          "mode": 0,
          "value": "ItemMacro.Maneuvers: Menacing Attack",
          "priority": "20"
        }
      ],
      "disabled": false,
      "duration": {
        "startTime": null
      },
      "icon": "systems/dnd5e/icons/skills/yellow_37.jpg",
      "label": "Maneuvers: Menacing Attack",
      "origin": "Item.2kG19Y9hHFRb7GYt",
      "transfer": false,
      "flags": {
        "dae": {
          "selfTarget": false,
          "stackable": "none",
          "durationExpression": "",
          "macroRepeat": "none",
          "specialDuration": [],
          "transfer": false
        },
        "core": {
          "statusId": ""
        },
        "dnd5e-helpers": {
          "rest-effect": "Ignore"
        },
        "ActiveAuras": {
          "isAura": false,
          "aura": "None",
          "radius": null,
          "alignment": "",
          "type": "",
          "ignoreSelf": false,
          "height": false,
          "hidden": false,
          "displayTemp": false,
          "hostile": false,
          "onlyOnce": false
        }
      },
      "tint": null,
      "selectedKey": "flags.dnd5e.DamageBonusMacro"
    }
  ],
  "flags": {
    "core": {
      "sourceId": "Item.2kG19Y9hHFRb7GYt"
    },
    "rest-recovery": {
      "data": {
        "recovery": {
          "enabled": false
        }
      }
    },
    "midi-qol": {
      "effectActivation": false
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": true
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Maneuvers: Menacing Attack",
          "type": "script",
          "author": "otqBqyqMuTGDffTr",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "// menacing attack\n\n// macro.itemMacro.GM with args[1] being @token, on active effect\n// requires DAE, Itemacro, Midi-QOL, More Hooks D&D5e, optionally CV, Levels\n\nconst lastArg = args[args.length - 1];\nconst token = canvas.tokens.get(lastArg.tokenId);\nconst tokenOrActor = await fromUuid(lastArg.actorUuid);\nconst tactor = tokenOrActor.actor ? tokenOrActor.actor : tokenOrActor;\nconst sourceToken = canvas.tokens.get(args[1]);\n\n// canSee by tposney via midi-qol utils.js\nasync function canSee(tokenEntity, targetEntity) {\n\t//TODO - requires rewrite for v10\n\t//@ts-ignore\n\tlet target = targetEntity instanceof TokenDocument ? targetEntity.object : targetEntity;\n\t//@ts-ignore\n\tlet token = tokenEntity instanceof TokenDocument ? tokenEntity.object : tokenEntity;\n\tif (!token || !target)\n\t\treturn true;\n\tconst targetPoint = target.center;\n\tconst visionSource = token.vision;\n\tif (!token.vision.active)\n\t\treturn true; //TODO work out what to do with tokens with no vision\n\tconst lightSources = canvas?.lighting?.sources;\n\t// Determine the array of offset points to test\n\tconst t = Math.min(target.w, target.h) / 4;\n\tconst offsets = t > 0 ? [[0, 0], [-t, -t], [-t, t], [t, t], [t, -t], [-t, 0], [t, 0], [0, -t], [0, t]] : [[0, 0]];\n\tconst points = offsets.map(o => new PIXI.Point(targetPoint.x + o[0], targetPoint.y + o[1]));\n\t// If the point is entirely inside the buffer region, it may be hidden from view\n\t// if (!target._inBuffer && !points.some(p => canvas?.dimensions?.sceneRect.contains(p.x, p.y))) return false;\n\t// Check each point for one which provides both LOS and FOV membership\n\tconst returnValue = points.some(p => {\n\t\tlet hasLOS = false;\n\t\tlet hasFOV = false;\n\t\tlet requireFOV = !canvas?.lighting?.globalLight;\n\t\tif (!hasLOS || (!hasFOV && requireFOV)) { // Do we need to test for LOS?\n\t\t\tif (visionSource?.los?.contains(p.x, p.y)) {\n\t\t\t\thasLOS = true;\n\t\t\t\tif (!hasFOV && requireFOV) { // Do we need to test for FOV?\n\t\t\t\t\tif (visionSource?.fov?.contains(p.x, p.y))\n\t\t\t\t\t\thasFOV = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (hasLOS && (!requireFOV || hasFOV)) { // Did we satisfy all required conditions?\n\t\t\treturn true;\n\t\t}\n\t\t// Check light sources\n\t\tfor (let source of lightSources?.values() ?? []) {\n\t\t\tif (!source.active)\n\t\t\t\tcontinue;\n\t\t\t//@ts-ignore\n\t\t\tif (source.containsPoint(p)) {\n\t\t\t\t//@ts-ignore\n\t\t\t\tif (source.data.vision)\n\t\t\t\t\thasLOS = true;\n\t\t\t\thasFOV = true;\n\t\t\t}\n\t\t\tif (hasLOS && (!requireFOV || hasFOV))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t});\n\treturn returnValue;\n}\n\nasync function sightCheck(actorOrWorkflow, rollData) {\n    if (actorOrWorkflow.actor !== tactor && actorOrWorkflow !== tactor) return;\n    if (token && sourceToken) { \n        let canSeeSource = false;\n        if (game.modules.get(\"conditional-visibility\")?.active && game.modules.get(\"levels\")?.active && _levels) { \n            canSeeSource = game.modules.get('conditional-visibility')?.api?.canSee(token, sourceToken) && _levels?.advancedLosTestVisibility(token, sourceToken);\n        } else {\n            canSeeSource = canSee(token, sourceToken);\n        }\n        if (canSeeSource) {\n            if (rollData) {\n                Object.assign(rollData, { disadvantage: true });\n                return;\n            }\n            let ef = await tactor.effects.find(i => i.data === lastArg.efData);\n            let newChanges = [];\n            if (!ef.data.changes.find(c => c.key === \"flags.midi-qol.disadvantage.attack.all\")) newChanges.push({ key: \"flags.midi-qol.disadvantage.attack.all\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 0 });\n            if (!ef.data.changes.find(c => c.key === \"flags.midi-qol.disadvantage.ability.check.all\")) newChanges.push({ key: \"flags.midi-qol.disadvantage.ability.check.all\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 0 });\n            await ef.update({ changes: newChanges.concat(ef.data.changes) });\n            if (newChanges) {\n                newChanges = ef.data.changes.filter((c) => c.key !== \"flags.midi-qol.disadvantage.attack.all\" && c.key !== \"flags.midi-qol.disadvantage.ability.check.all\");\n                ef.update({ changes: newChanges });\n            }\n        } \n    }\n}\n\nif (args[0] === \"on\") {\n    if (game.modules.get(\"midi-qol\")?.active) {\n\t\tlet hookId1 = Hooks.on(\"midi-qol.preItemRoll\", sightCheck);\n\t\tDAE.setFlag(tactor, \"fearAtkHook\", hookId1);\n    }\n    \n    if (game.modules.get(\"more-hooks-5e\")?.active) {\n\t\tlet hookId2 = Hooks.on(\"Actor5e.preRollAbilityTest\", sightCheck);\n\t\tDAE.setFlag(tactor, \"fearAblHook\", hookId2);\n\n\t\tlet hookId3 = Hooks.on(\"Actor5e.preRollSkill\", sightCheck);\n\t\tDAE.setFlag(tactor, \"fearSklHook\", hookId3);\n    }\n}\n\nif (args[0] === \"off\") {\n    const flag1 = await DAE.getFlag(tactor, \"fearAtkHook\");\n\tif (flag1) {\n\t\tHooks.off(\"midi-qol.preItemRoll\", flag1);\n\t\tawait DAE.unsetFlag(tactor, \"fearAtkHook\");\n\t}\n    \n    const flag2 = await DAE.getFlag(tactor, \"fearAblHook\");\n\tif (flag2) {\n\t\tHooks.off(\"Actor5e.preRollAbilityTest\", flag2);\n\t\tawait DAE.unsetFlag(tactor, \"fearAblHook\");\n\t}\n    \n    const flag3 = await DAE.getFlag(tactor, \"fearSklHook\");\n\tif (flag3) {\n\t\tHooks.off(\"Actor5e.preRollSkill\", flag3);\n\t\tawait DAE.unsetFlag(tactor, \"fearSklHook\");\n\t}\n}\n\ntry {\n\n\tif (args[0].tag !== \"DamageBonus\" || ![\"mwak\", \"rwak\"].includes(args[0].itemData.data.actionType)|| args[0].hitTargetUuids.length < 1) return {};\n\tconst tokenOrActorTarget = await fromUuid(args[0].hitTargetUuids[0]);\n    const tactorTarget = tokenOrActorTarget.actor ? tokenOrActorTarget.actor : tokenOrActorTarget;\n\tconst die = tactor.data.data.scale[\"battle-master\"][\"combat-superiority-die\"].slice(1);\n    let dieCount = Object.values(tactor.data.data.resources).find(r => r.label === \"Combat Superiority\");\n\t\n\tif (die && dieCount && dieCount.value > 0) {\n\n\t\tlet dialog = new Promise((resolve, reject) => {\n\t\t\tnew Dialog({\n\t\t\ttitle: \"Menacing Attack: Usage Configuration\",\n\t\t\tcontent: `\n\t\t\t<form id=\"use-form\">\n\t\t\t\t<p>` + game.i18n.format(\"DND5E.AbilityUseHint\", {name: \"Maneuvers: Menacing Attack\", type: \"feature\"}) + `</p>\n\t\t\t\t<p>Use a Superiority Die to use Menacing Attack?</p>\n\t\t\t\t<p>(` + dieCount.value + ` Superiority Die Remaining)</p>\n\t\t\t</form>\n\t\t\t`,\n\t\t\tbuttons: {\n\t\t\t\tone: {\n\t\t\t\t\ticon: '<i class=\"fas fa-check\"></i>',\n\t\t\t\t\tlabel: \"Confirm\",\n\t\t\t\t\tcallback: () => resolve(true)\n\t\t\t\t},\n\t\t\t\ttwo: {\n\t\t\t\t\ticon: '<i class=\"fas fa-times\"></i>',\n\t\t\t\t\tlabel: \"Cancel\",\n\t\t\t\t\tcallback: () => {resolve(false)}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdefault: \"two\",\n\t\t    close: callBack => {resolve(false)}\n\t\t\t}).render(true);\n\t\t});\n\t\tmaneuver = await dialog;\n\t\t\n\t\tif (!maneuver) return {};\n\t\t\n\t\tdieCount = Object.values(tactor.data.data.resources).find(r => r.label === \"Combat Superiority\");\n\t\tif (dieCount.value < 1) {\n\t\t\tui.notifications.warn(\"Menacing Attack: No Superiority Die Remaining\");\n\t\t\treturn {};\n\t\t} else {\n\t\t\tawait tactor.update({ 'data.resources.primary.value' : dieCount.value - 1 });\n\t\t}\n\t\t\n        const rollData = tactor.getRollData();\n        const strDC = 8 + rollData.attributes.prof + rollData.abilities.str.mod;\n        const dexDC = 8 + rollData.attributes.prof + rollData.abilities.dex.mod;\n        const saveDC = strDC > dexDC ? strDC : dexDC;\n        const resist = [\"Brave\", \"Fear Resilience\"];\n        const getResist = tactorTarget.items.find(i => resist.includes(i.name)) || tactorTarget.effects.find(i => resist.includes(i.data.label));\n        const ability = \"wis\";\n        const rollOptions = getResist ? { request: \"save\", targetUuid: tactorTarget.uuid, ability: ability, advantage: true } : { request: \"save\", targetUuid: tactorTarget.uuid, ability: ability };\n        let roll = await MidiQOL.socket().executeAsGM(\"rollAbility\", rollOptions);\n        if (game.dice3d) game.dice3d.showForRoll(roll);\n        if (roll.total < saveDC) {\n            const item = await tactor.items.find(i => i.name.toLowerCase().includes(\"menacing attack\"));\n            let effectData = [{\n                changes: [\n                    { key: `macro.itemMacro.GM`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: args[0].tokenId, priority: 20 }\n                ],\n                origin: args[0].uuid,\n                flags: {\n                    \"dae\": { itemData: item.data, token: tactorTarget.uuid, specialDuration: [\"turnEndSource\"] },\n                    \"core\": { statusId: \"Frightened\" }\n                },\n                disabled: false,\n                icon: \"icons/svg/terror.svg\",\n                label: \"Frightened\"\n            }];\n            await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: tactorTarget.uuid, effects: effectData });\n        }\n\t\t\n\t\tconst diceMult = args[0].isCritical ? 2: 1;\n\t\tconst damageType = args[0].item.data.damage.parts[0][1];\n\t\t\n\t\treturn {damageRoll: `${diceMult}${die}[${damageType}]`, flavor: \"Menacing Attack\"};\n\t}\n} catch(err) {\n\tconsole.error(`${args[0].itemData.name} - maneuver macro`, err);\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        }
      }
    },
    "scene-packer": {
      "hash": "da0fd8865ebede4d6996b008bfec6fee574d117a",
      "sourceId": "Item.BZt0AzP2QGCn3rj2"
    },
    "exportSource": {
      "world": "Curse of Strahd",
      "system": "dnd5e",
      "coreVersion": "9.280",
      "systemVersion": "1.6.3"
    }
  }
}
{
  "name": "Fey Presence",
  "type": "feat",
  "img": "icons/magic/unholy/orb-hands-pink.webp",
  "data": {
    "description": {
      "value": "<p>Once per short rest, as an action, you can cause each creature in a 10-ft. cube from you to make a WIS saving throw or become @Compendium[dnd5e.rules.Charmed]{charmed} or @Compendium[dnd5e.rules.Frightened]{frightened} by you (your choice) until the end of your next turn.</p>\n<details>\n<summary>More Details</summary>\n<p> </p>\n<p class=\"Basic-Paragraph\">Starting at 1st level, your patron bestows upon you the ability to project the beguiling and fearsome presence of the fey. As an action, you can cause each creature in a 10-foot cube originating from you to make a Wisdom saving throw against your warlock spell save DC. The creatures that fail their saving throws are all @Compendium[dnd5e.rules.Charmed]{charmed} or @Compendium[dnd5e.rules.Frightened]{frightened} by you (your choice) until the end of your next turn.</p>\n<p class=\"Core-Styles_Core-Body\">Once you use this feature, you can’t use it again until you finish a short or long rest.</p>\n<p> </p>\n</details>",
      "chat": "",
      "unidentified": ""
    },
    "source": "",
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": null,
      "units": ""
    },
    "target": {
      "value": 10,
      "width": null,
      "units": "ft",
      "type": "cube"
    },
    "range": {
      "value": 5,
      "long": null,
      "units": "ft"
    },
    "uses": {
      "value": 1,
      "max": "1",
      "per": "sr"
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "save",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": ""
    },
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "wis",
      "dc": null,
      "scaling": "spell"
    },
    "requirements": "",
    "recharge": {
      "value": null,
      "charged": false
    },
    "attunement": null
  },
  "effects": [
    {
      "_id": "ZMRShyrnoIWJaTyS",
      "changes": [
        {
          "key": "macro.itemMacro.GM",
          "mode": 0,
          "value": "@token",
          "priority": "20"
        }
      ],
      "disabled": false,
      "duration": {
        "startTime": null
      },
      "icon": "icons/magic/unholy/orb-hands-pink.webp",
      "label": "Fey Presence",
      "origin": "Item.hpxZJ1FHtUQOO4nz",
      "transfer": false,
      "flags": {
        "dae": {
          "selfTarget": false,
          "stackable": "none",
          "durationExpression": "",
          "macroRepeat": "none",
          "specialDuration": [
            "turnEndSource"
          ],
          "transfer": false
        },
        "core": {
          "statusId": ""
        },
        "dnd5e-helpers": {
          "rest-effect": "Ignore"
        },
        "ActiveAuras": {
          "isAura": false,
          "aura": "None",
          "radius": null,
          "alignment": "",
          "type": "",
          "ignoreSelf": false,
          "height": false,
          "hidden": false,
          "displayTemp": false,
          "hostile": false,
          "onlyOnce": false
        }
      },
      "tint": null,
      "selectedKey": "macro.itemMacro.GM"
    }
  ],
  "flags": {
    "ddbimporter": {
      "id": "1035",
      "entityTypeId": "222216831",
      "componentId": 396,
      "componentTypeId": 12168134,
      "class": "Warlock",
      "subclass": "The Archfey",
      "dndbeyond": {
        "levelScale": null,
        "levelScales": [],
        "limitedUse": [
          {
            "level": null,
            "uses": 1
          }
        ]
      },
      "importId": "9tx0852oltv2kuxo"
    },
    "infusions": {
      "infused": false
    },
    "obsidian": {
      "source": {
        "type": "class",
        "text": "Warlock"
      }
    },
    "scene-packer": {
      "hash": "54f4a9b6db26f7aa7b6926cd36e9b43ade7abbec",
      "sourceId": "Item.RJQnZ7vm4GTOJuBW"
    },
    "core": {
      "sourceId": "Item.hpxZJ1FHtUQOO4nz"
    },
    "rest-recovery": {
      "data": {
        "recovery": {
          "enabled": false
        }
      }
    },
    "midi-qol": {
      "effectActivation": false,
      "onUseMacroName": "[preItemRoll]ItemMacro,[postActiveEffects]ItemMacro"
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "enhanced-terrain-layer": {
      "multiple": null,
      "elevation": null,
      "depth": null,
      "environment": ""
    },
    "itemacro": {
      "macro": {
        "_id": null,
        "name": "Fey Presence",
        "type": "script",
        "author": "ckiTPzlaPztdkjV6",
        "img": "icons/svg/dice-target.svg",
        "scope": "global",
        "command": "// fey presence\n\nconst lastArg = args[args.length - 1];\nconst token = canvas.tokens.get(lastArg.tokenId);\nconst tokenOrActor = await fromUuid(lastArg.actorUuid);\nconst tactor = tokenOrActor.actor ? tokenOrActor.actor : tokenOrActor;\nconst sourceToken = canvas.tokens.get(args[1]);\nconst sourceActor = sourceToken?.actor ?? sourceToken?._actor;\n\n// canSee by tposney via midi-qol utils.js\nasync function canSee(tokenEntity, targetEntity) {\n\t//TODO - requires rewrite for v10\n\t//@ts-ignore\n\tlet target = targetEntity instanceof TokenDocument ? targetEntity.object : targetEntity;\n\t//@ts-ignore\n\tlet token = tokenEntity instanceof TokenDocument ? tokenEntity.object : tokenEntity;\n\tif (!token || !target)\n\t\treturn true;\n\tconst targetPoint = target.center;\n\tconst visionSource = token.vision;\n\tif (!token.vision.active)\n\t\treturn true; //TODO work out what to do with tokens with no vision\n\tconst lightSources = canvas?.lighting?.sources;\n\t// Determine the array of offset points to test\n\tconst t = Math.min(target.w, target.h) / 4;\n\tconst offsets = t > 0 ? [[0, 0], [-t, -t], [-t, t], [t, t], [t, -t], [-t, 0], [t, 0], [0, -t], [0, t]] : [[0, 0]];\n\tconst points = offsets.map(o => new PIXI.Point(targetPoint.x + o[0], targetPoint.y + o[1]));\n\t// If the point is entirely inside the buffer region, it may be hidden from view\n\t// if (!target._inBuffer && !points.some(p => canvas?.dimensions?.sceneRect.contains(p.x, p.y))) return false;\n\t// Check each point for one which provides both LOS and FOV membership\n\tconst returnValue = points.some(p => {\n\t\tlet hasLOS = false;\n\t\tlet hasFOV = false;\n\t\tlet requireFOV = !canvas?.lighting?.globalLight;\n\t\tif (!hasLOS || (!hasFOV && requireFOV)) { // Do we need to test for LOS?\n\t\t\tif (visionSource?.los?.contains(p.x, p.y)) {\n\t\t\t\thasLOS = true;\n\t\t\t\tif (!hasFOV && requireFOV) { // Do we need to test for FOV?\n\t\t\t\t\tif (visionSource?.fov?.contains(p.x, p.y))\n\t\t\t\t\t\thasFOV = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (hasLOS && (!requireFOV || hasFOV)) { // Did we satisfy all required conditions?\n\t\t\treturn true;\n\t\t}\n\t\t// Check light sources\n\t\tfor (let source of lightSources?.values() ?? []) {\n\t\t\tif (!source.active)\n\t\t\t\tcontinue;\n\t\t\t//@ts-ignore\n\t\t\tif (source.containsPoint(p)) {\n\t\t\t\t//@ts-ignore\n\t\t\t\tif (source.data.vision)\n\t\t\t\t\thasLOS = true;\n\t\t\t\thasFOV = true;\n\t\t\t}\n\t\t\tif (hasLOS && (!requireFOV || hasFOV))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t});\n\treturn returnValue;\n}\n\nasync function sightCheck(actorOrWorkflow, rollData) {\n    if (actorOrWorkflow.actor !== tactor && actorOrWorkflow !== tactor) return;\n    if (token && sourceToken) { \n        let canSeeSource = false;\n        if (game.modules.get(\"conditional-visibility\")?.active && game.modules.get(\"levels\")?.active && _levels) { \n            canSeeSource = game.modules.get('conditional-visibility')?.api?.canSee(token, sourceToken) && _levels?.advancedLosTestVisibility(token, sourceToken);\n        } else {\n            canSeeSource = canSee(token, sourceToken);\n        }\n        if (canSeeSource) {\n            if (rollData) {\n                Object.assign(rollData, { disadvantage: true });\n                return;\n            }\n            let ef = await tactor.effects.find(i => i.data === lastArg.efData);\n            let newChanges = [];\n            if (!ef.data.changes.find(c => c.key === \"flags.midi-qol.disadvantage.attack.all\")) newChanges.push({ key: \"flags.midi-qol.disadvantage.attack.all\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 0 });\n            if (!ef.data.changes.find(c => c.key === \"flags.midi-qol.disadvantage.ability.check.all\")) newChanges.push({ key: \"flags.midi-qol.disadvantage.ability.check.all\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 0 });\n            await ef.update({ changes: newChanges.concat(ef.data.changes) });\n            if (newChanges) {\n                newChanges = ef.data.changes.filter((c) => c.key !== \"flags.midi-qol.disadvantage.attack.all\" && c.key !== \"flags.midi-qol.disadvantage.ability.check.all\");\n                ef.update({ changes: newChanges });\n            }\n        } \n    }\n}\n\nif (args[0].tag === \"OnUse\" && args[0].macroPass === \"preItemRoll\") {\n\tlet dialog = new Promise(async (resolve, reject) => {\n        let errorMessage;\n        new Dialog({\n            title: `${item.name}`,\n            content: `Apply Charmed or Frightened?`,\n            buttons: {\n\t\t\t\tcharmed: {\n\t\t\t\t\tlabel: \"Charmed\",\n\t\t\t\t\tcallback: () => {resolve(true)}\n\t\t\t\t},\n\t\t\t\tfrightened: {\n\t\t\t\t\tlabel: \"Frightened\",\n\t\t\t\t\tcallback: () => {resolve(false)}\n\t\t\t\t}\n\t\t\t},\n            close: async (html) => {\n                if(errorMessage) reject(new Error(errorMessage));\n            },\n            default: \"charmed\"\n        }).render(true);\n    });\n    let efCharmed = await dialog;\n\tif (efCharmed) {\n\t\tlet effectData = {\n            label: \"Fey Presence Charm\",\n            icon: \"icons/magic/unholy/orb-hands-pink.webp\",\n            origin: lastArg.uuid,\n            flags: { dae: { specialDuration: [\"turnEnd\"] }}, \n            disabled: false\n        };\n        await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: tactor.uuid, effects: [effectData] });\n\t} else {\n\t\tlet effectData = {\n            label: \"Fey Presence Frighten\",\n            icon: \"icons/magic/unholy/orb-hands-pink.webp\",\n            origin: lastArg.uuid,\n            flags: { dae: { specialDuration: [\"turnEnd\"] }}, \n            disabled: false\n        };\n        await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: tactor.uuid, effects: [effectData] });\n\t}\n}\n\nif (args[0].tag === \"OnUse\" && lastArg.targetUuids.length > 0 && args[0].macroPass === \"preSave\") {\n\tif (tactor.effects.find(e => e.data.label === \"Fey Presence Frighten\")) {\n\t\tconst resist = [\"Brave\", \"Fear Resilience\"];\n\t\tfor (let i = 0; i < lastArg.targetUuids.length; i++) {\n\t\t\tlet tokenOrActorTarget = await fromUuid(lastArg.targetUuids[i]);\n\t\t\tlet tactorTarget = tokenOrActorTarget.actor ? tokenOrActorTarget.actor : tokenOrActorTarget;\n\t\t\tlet getResist = tactorTarget.items.find(i => resist.includes(i.name));\n\t\t\tif (getResist) {\n\t\t\t\tconst effectData = {\n\t\t\t\t\tchanges: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkey: \"flags.midi-qol.advantage.ability.save.all\",\n\t\t\t\t\t\t\tmode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n\t\t\t\t\t\t\tvalue: 1,\n\t\t\t\t\t\t\tpriority: 20,\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\tdisabled: false,\n\t\t\t\t\tflags: { dae: { specialDuration: [\"isSave\"] } },\n\t\t\t\t\ticon: args[0].item.img,\n\t\t\t\t\tlabel: `${args[0].item.name} Save Advantage`,\n\t\t\t\t};\n\t\t\t\tawait tactorTarget.createEmbeddedDocuments(\"ActiveEffect\", [effectData]);\n\t\t\t}\n\t\t}\n\t} else if (tactor.effects.find(e => e.data.label === \"Fey Presence Charm\")) {\n\t\tif (args[0].tag === \"OnUse\" && lastArg.targetUuids.length > 0 && args[0].macroPass === \"preSave\") {\n\t\t\tconst resist = [\"Fey Ancestry\", \"Duergar Reslience\", \"Charm Resilience\"];\n\t\t\tfor (let i = 0; i < lastArg.targetUuids.length; i++) {\n\t\t\t\tlet tokenOrActorTarget = await fromUuid(lastArg.targetUuids[i]);\n\t\t\t\tlet tactorTarget = tokenOrActorTarget.actor ? tokenOrActorTarget.actor : tokenOrActorTarget;\n\t\t\t\tlet getResist = tactorTarget.items.find(i => resist.includes(i.name));\n\t\t\t\tif (getResist) {\n\t\t\t\t\tconst effectData = {\n\t\t\t\t\t\tchanges: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tkey: \"flags.midi-qol.advantage.ability.save.all\",\n\t\t\t\t\t\t\t\tmode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n\t\t\t\t\t\t\t\tvalue: 1,\n\t\t\t\t\t\t\t\tpriority: 20,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t],\n\t\t\t\t\t\tdisabled: false,\n\t\t\t\t\t\tflags: { dae: { specialDuration: [\"isSave\"] } },\n\t\t\t\t\t\ticon: args[0].item.img,\n\t\t\t\t\t\tlabel: `${args[0].item.name} Save Advantage`,\n\t\t\t\t\t};\n\t\t\t\t\tawait tactorTarget.createEmbeddedDocuments(\"ActiveEffect\", [effectData]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nif (args[0] === \"on\") {\n\tlet fear = sourceActor.effects.find(i => i.data.label === \"Fey Presence Frighten\");\n\tlet charm = sourceActor.effects.find(i => i.data.label === \"Fey Presence Charm\");\n\tif (fear) {\n\t\tlet ef = tactor.effects.find(i => i.data === lastArg.efData);\n\t\tif (ef) ef.update({ label: \"Frightened\", icon: \"icons/svg/terror.svg\", flags: { core: { statusId: \"Frightened\" } } });\n\n\t\tif (game.modules.get(\"midi-qol\")?.active) {\n\t\t\tlet hookId1 = Hooks.on(\"midi-qol.preItemRoll\", sightCheck);\n\t\t\tDAE.setFlag(tactor, \"fearAtkHookFP\", hookId1);\n\t\t}\n\t\t\n\t\tif (game.modules.get(\"more-hooks-5e\")?.active) {\n\t\t\tlet hookId2 = Hooks.on(\"Actor5e.preRollAbilityTest\", sightCheck);\n\t\t\tDAE.setFlag(tactor, \"fearAblHookFP\", hookId2);\n\t\n\t\t\tlet hookId3 = Hooks.on(\"Actor5e.preRollSkill\", sightCheck);\n\t\t\tDAE.setFlag(tactor, \"fearSklHookFP\", hookId3);\n\t\t}\n\t} else if (charm) {\n\t\tlet ef = tactor.effects.find(i => i.data === lastArg.efData);\n\t\tconst changes = [\n\t\t\t{\n\t\t\t\tkey: \"StatusEffect\",\n\t\t\t\tmode: CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n\t\t\t\tpriority: 0,\n\t\t\t\tvalue: \"Convenient Effect: Charmed\"\n\t\t\t},\n\t\t\t{\n\t\t\t\tkey: \"flags.midi-qol.charm\",\n\t\t\t\tmode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE,\n\t\t\t\tpriority: 0,\n\t\t\t\tvalue: `${args[1]}`\n\t\t\t}\n\t\t]\n\t\tif (ef) ef.update({ label: \"Charmed\", icon: \"modules/dfreds-convenient-effects/images/charmed.svg\", flags: { core: { statusId: \"Convenient Effect: Charmed\" } }, changes: changes });\n\t}\n}\n\nif (args[0] === \"off\") {\n    const flag1 = await DAE.getFlag(tactor, \"fearAtkHookFP\");\n\tif (flag1) {\n\t\tHooks.off(\"midi-qol.preItemRoll\", flag1);\n\t\tawait DAE.unsetFlag(tactor, \"fearAtkHookFP\");\n\t}\n    \n    const flag2 = await DAE.getFlag(tactor, \"fearAblHookFP\");\n\tif (flag2) {\n\t\tHooks.off(\"Actor5e.preRollAbilityTest\", flag2);\n\t\tawait DAE.unsetFlag(tactor, \"fearAblHookFP\");\n\t}\n    \n    const flag3 = await DAE.getFlag(tactor, \"fearSklHookFP\");\n\tif (flag3) {\n\t\tHooks.off(\"Actor5e.preRollSkill\", flag3);\n\t\tawait DAE.unsetFlag(tactor, \"fearSklHookFP\");\n\t}\n}",
        "folder": null,
        "sort": 0,
        "permission": {
          "default": 0
        },
        "flags": {}
      }
    },
    "exportSource": {
      "world": "dnd5e",
      "system": "dnd5e",
      "coreVersion": "9.280",
      "systemVersion": "1.6.3"
    }
  }
}
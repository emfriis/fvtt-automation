{
  "name": "Blood Drain",
  "type": "weapon",
  "img": "icons/skills/wounds/blood-spurt-spray-red.webp",
  "data": {
    "description": {
      "value": "<section class=\"secret\">\n<p><em>Melee Weapon Attack:</em><strong>+5 to hit,</strong>, <strong>5 ft.,</strong> one creature. Hit: <strong>5 (1d4 + 3) <em>piercing damage</em></strong>.</p>\n<p>The stirge attaches to the target. While attached, the stirge doesn't attack. Instead, at the start of each of the stirge's turns, the target loses 5 (1d4 + 3) hit points due to blood loss.The stirge can detach itself by spending 5 feet of its movement. It does so after it drains 10 hit points of blood from the target or the target dies.</p>\n</section>\n<p>The Stirge attacks with its Blood Drain. A creature, including the target, can use its action to detach the stirge.</p>",
      "chat": "",
      "unidentified": ""
    },
    "source": "",
    "quantity": 1,
    "weight": 0,
    "price": "0",
    "attunement": 0,
    "equipped": true,
    "rarity": "",
    "identified": true,
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": null,
      "units": ""
    },
    "target": {
      "value": null,
      "width": null,
      "units": "",
      "type": ""
    },
    "range": {
      "value": null,
      "long": null,
      "units": ""
    },
    "uses": {
      "value": 0,
      "max": "0",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "dex",
    "actionType": "mwak",
    "attackBonus": "0",
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": ""
    },
    "damage": {
      "parts": [
        [
          "1d4 + @mod",
          "piercing"
        ]
      ],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell"
    },
    "armor": {
      "value": 10
    },
    "hp": {
      "value": 0,
      "max": 0,
      "dt": null,
      "conditions": ""
    },
    "weaponType": "natural",
    "baseItem": "",
    "properties": {
      "amm": false,
      "fin": false,
      "fir": false,
      "foc": false,
      "hvy": false,
      "lgt": false,
      "lod": false,
      "rch": false,
      "rel": false,
      "ret": false,
      "spc": false,
      "thr": false,
      "two": false,
      "ver": false,
      "ada": false,
      "mgc": false,
      "sil": false
    },
    "proficient": true,
    "attuned": false
  },
  "effects": [],
  "flags": {
    "rest-recovery": {
      "data": {
        "recovery": {
          "enabled": false
        }
      }
    },
    "midi-qol": {
      "fumbleThreshold": null,
      "effectActivation": false,
      "onUseMacroName": "[postActiveEffects]ItemMacro"
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Blood Drain",
          "type": "script",
          "author": "otqBqyqMuTGDffTr",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "const lastArg = args[args.length - 1];\nconst token = canvas.tokens.get(lastArg.tokenId);\nconst tokenOrActor = await fromUuid(lastArg.actorUuid);\nconst tactor = tokenOrActor.actor ? tokenOrActor.actor : tokenOrActor;\n\nasync function attemptRemoval() {\n    const tokenOrActorSource = await fromUuid(args[1]);\n    const tactorSource = tokenOrActorSource.actor ? tokenOrActorSource.actor : tokenOrActorSource;\n\n    if (tactor === tactorSource) {\n        const tokenTarget = canvas.tokens.get(args[2]);\n        const sourceItem = await fromUuid(lastArg.efData.origin);\n        const damageRoll = await new Roll(`1d4 + 3`).evaluate({ async: true });\n        if (game.dice3d) game.dice3d.showForRoll(damageRoll);\n        const workflowItemData = duplicate(sourceItem.data);\n        workflowItemData.data.target = { value: 1, units: \"\", type: \"creature\" };\n        workflowItemData.name = \"Blood Drain\";\n\n        await new MidiQOL.DamageOnlyWorkflow(\n            tactor,\n            token.data,\n            damageRoll.total,\n            \"\",\n            [tokenTarget],\n            damageRoll,\n            {\n              flavor: \"Blood Drain\",\n              itemCardId: \"new\",\n              itemData: workflowItemData,\n              isCritical: false,\n            }\n        );\n\n        const flag = await DAE.getFlag(tactor, \"bloodDrain\");\n\t    if (flag) {\n            if (flag + damageRoll.total >= 10) {\n                let drain = tactorSource.effects.find(i => i.data.label === \"Blood Drain Attached\");\n\t\t        if (drain) await tactorSource.deleteEmbeddedDocuments(\"ActiveEffect\", [drain.id]);\n                await DAE.unsetFlag(tactorSource, \"bloodDrain\");\n                return;\n            }\n            await DAE.setFlag(tactor, \"bloodDrain\", flag += damageRoll.total);\n        } else {\n            await DAE.setFlag(tactor, \"bloodDrain\", damageRoll.total);\n        }\n    }\n\n    new Dialog({\n        title: `Use action to remove ${lastArg.efData.label}?`,\n        buttons: {\n            one: {\n            label: \"Yes\",\n            callback: async () => {\n                let drain = tactorSource.effects.find(i => i.data.label === \"Blood Drain Attached\");\n\t\t        if (drain) await tactorSource.deleteEmbeddedDocuments(\"ActiveEffect\", [drain.id]);\n                await DAE.unsetFlag(tactorSource, \"drain\");\n            },\n            },\n            two: {\n            label: \"No\",\n            callback: () => {},\n            },\n        },\n    }).render(true);\n}\n\nif (args[0].tag === \"OnUse\" && lastArg.hitTargetUuids.length > 0) {\n    const tokenIdTarget = lastArg.hitTargets[0].id ?? lastArg.hitTargets[0]._id;\n    const tokenOrActorTarget = await fromUuid(lastArg.hitTargetUuids[0]);\n    const tactorTarget = tokenOrActorTarget.actor ? tokenOrActorTarget.actor : tokenOrActorTarget;      \n    const effectData = {\n        changes: [\n            { key: `macro.itemMacro`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: `${tokenOrActor.uuid} ${tokenIdTarget}`, priority: 20 },\n        ],\n        disabled: false,\n        origin: lastArg.item.uuid,\n        flags: { \n            dae: { macroRepeat: \"startEveryTurn\" },\n            core: { statusId: \"Blood Drain\" } \n        },\n        icon: lastArg.item.img,\n        label: \"Blood Drain\"\n    };\n    await tactorTarget.createEmbeddedDocuments(\"ActiveEffect\", [effectData]);\n\n    let drain = await tactorTarget.effects.find(i => i.data.label === \"Blood Drain\");\n\n    const effectData2 = {\n        changes: [\n            { key: `macro.itemMacro`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: `${tokenOrActor.uuid} ${tokenIdTarget}`, priority: 20 },\n            { key: `flags.dae.deleteUuid`, mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: drain.uuid, priority: 20 }\n        ],\n        disabled: false,\n        origin: lastArg.item.uuid,\n        flags: { \n            dae: { macroRepeat: \"startEveryTurn\" },\n            core: { statusId: \"Blood Drain Attached\" } \n        },\n        icon: lastArg.item.img,\n        label: \"Blood Drain Attached\"\n    };\n    await tactor.createEmbeddedDocuments(\"ActiveEffect\", [effectData2]);\n}\n\nif (args[0] === \"each\") {\n    attemptRemoval();\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        },
        "_id": null,
        "name": "Blood Drain",
        "type": "script",
        "author": "ckiTPzlaPztdkjV6",
        "img": "icons/svg/dice-target.svg",
        "scope": "global",
        "command": "const lastArg = args[args.length - 1];\nconst token = canvas.tokens.get(lastArg.tokenId);\nconst tokenOrActor = await fromUuid(lastArg.actorUuid);\nconst tactor = tokenOrActor.actor ? tokenOrActor.actor : tokenOrActor;\n\nasync function attemptRemoval() {\n    const tokenOrActorSource = await fromUuid(args[1]);\n    const tactorSource = tokenOrActorSource.actor ? tokenOrActorSource.actor : tokenOrActorSource;\n\n    if (tactor === tactorSource) {\n        const tokenTarget = canvas.tokens.get(args[2]);\n        const sourceItem = await fromUuid(lastArg.efData.origin);\n        const damageRoll = await new Roll(`1d4 + 3`).evaluate({ async: true });\n        if (game.dice3d) game.dice3d.showForRoll(damageRoll);\n        const workflowItemData = duplicate(sourceItem.data);\n        workflowItemData.data.target = { value: 1, units: \"\", type: \"creature\" };\n        workflowItemData.name = \"Blood Drain\";\n\n        await new MidiQOL.DamageOnlyWorkflow(\n            tactor,\n            token.data,\n            damageRoll.total,\n            \"\",\n            [tokenTarget],\n            damageRoll,\n            {\n              flavor: \"Blood Drain\",\n              itemCardId: \"new\",\n              itemData: workflowItemData,\n              isCritical: false,\n            }\n        );\n\n        const flag = await DAE.getFlag(tactor, \"bloodDrain\");\n\t    if (flag) {\n            if (flag + damageRoll.total >= 10) {\n                let drain = tactorSource.effects.find(i => i.data.label === \"Blood Drain Attached\");\n\t\t        if (drain) await tactorSource.deleteEmbeddedDocuments(\"ActiveEffect\", [drain.id]);\n                await DAE.unsetFlag(tactorSource, \"bloodDrain\");\n                return;\n            }\n            await DAE.setFlag(tactor, \"bloodDrain\", flag + damageRoll.total);\n        } else {\n            await DAE.setFlag(tactor, \"bloodDrain\", damageRoll.total);\n        }\n    }\n\n    new Dialog({\n        title: `Use action to remove ${lastArg.efData.label}?`,\n        buttons: {\n            one: {\n            label: \"Yes\",\n            callback: async () => {\n                let drain = tactorSource.effects.find(i => i.data.label === \"Blood Drain Attached\");\n\t\t        if (drain) await tactorSource.deleteEmbeddedDocuments(\"ActiveEffect\", [drain.id]);\n                await DAE.unsetFlag(tactorSource, \"drain\");\n            },\n            },\n            two: {\n            label: \"No\",\n            callback: () => {},\n            },\n        },\n    }).render(true);\n}\n\nif (args[0].tag === \"OnUse\" && lastArg.hitTargetUuids.length > 0) {\n    const tokenIdTarget = lastArg.hitTargets[0].id ?? lastArg.hitTargets[0]._id;\n    const tokenOrActorTarget = await fromUuid(lastArg.hitTargetUuids[0]);\n    const tactorTarget = tokenOrActorTarget.actor ? tokenOrActorTarget.actor : tokenOrActorTarget;      \n    const effectData = {\n        changes: [\n            { key: `macro.itemMacro`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: `${tokenOrActor.uuid} ${tokenIdTarget}`, priority: 20 },\n        ],\n        disabled: false,\n        origin: lastArg.item.uuid,\n        flags: { \n            dae: { macroRepeat: \"startEveryTurn\" },\n            core: { statusId: \"Blood Drain\" } \n        },\n        icon: lastArg.item.img,\n        label: \"Blood Drain\"\n    };\n    await tactorTarget.createEmbeddedDocuments(\"ActiveEffect\", [effectData]);\n\n    let drain = await tactorTarget.effects.find(i => i.data.label === \"Blood Drain\");\n\n    const effectData2 = {\n        changes: [\n            { key: `macro.itemMacro`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: `${tokenOrActor.uuid} ${tokenIdTarget}`, priority: 20 },\n            { key: `flags.dae.deleteUuid`, mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: drain.uuid, priority: 20 }\n        ],\n        disabled: false,\n        origin: lastArg.item.uuid,\n        flags: { \n            dae: { macroRepeat: \"startEveryTurn\" },\n            core: { statusId: \"Blood Drain Attached\" } \n        },\n        icon: lastArg.item.img,\n        label: \"Blood Drain Attached\"\n    };\n    await tactor.createEmbeddedDocuments(\"ActiveEffect\", [effectData2]);\n}\n\nif (args[0] === \"each\") {\n    attemptRemoval();\n}\n\nif (args[0] === \"off\") {\n    const flag = await DAE.getFlag(tactor, \"bloodDrain\");\n\tif (flag) {\n        await DAE.unsetFlag(tactor, \"bloodDrain\");\n    }\n}",
        "folder": null,
        "sort": 0,
        "permission": {
          "default": 0
        },
        "flags": {}
      }
    },
    "scene-packer": {
      "hash": "ee48acd65f80afb27b15925df9e2a31f94360741",
      "sourceId": "Item.JQMd9QcvWdtc4lAk"
    },
    "core": {
      "sourceId": "Item.JQMd9QcvWdtc4lAk"
    },
    "exportSource": {
      "world": "dnd5e",
      "system": "dnd5e",
      "coreVersion": "9.280",
      "systemVersion": "1.6.3"
    }
  }
}
{
  "name": "Wrathful Smite",
  "type": "spell",
  "img": "systems/dnd5e/icons/spells/enchant-royal-2.jpg",
  "data": {
    "description": {
      "value": "<p>The next time you hit with a melee weapon attack during this spellâ€™s duration, your attack deals an extra 1d6 psychic damage. Additionally, if the target is a creature, it must make a Wisdom saving throw or be @Compendium[dnd5e.rules.Frightened]{frightened} of you until the spell ends. As an action, the creature can make a Wisdom check against your spell save DC to steel its resolve and end this spell.</p>",
      "chat": "",
      "unidentified": ""
    },
    "source": "Player's Handbook pg 289",
    "activation": {
      "type": "bonus",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": 1,
      "units": "minute"
    },
    "target": {
      "value": null,
      "width": null,
      "units": "",
      "type": "self"
    },
    "range": {
      "value": null,
      "long": null,
      "units": "self"
    },
    "uses": {
      "value": null,
      "max": "",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "other",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": ""
    },
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell"
    },
    "level": 1,
    "school": "evo",
    "components": {
      "value": "",
      "vocal": true,
      "somatic": false,
      "material": false,
      "ritual": false,
      "concentration": true
    },
    "materials": {
      "value": "",
      "consumed": false,
      "cost": 0,
      "supply": 0
    },
    "preparation": {
      "mode": "prepared",
      "prepared": false
    },
    "scaling": {
      "mode": "none",
      "formula": ""
    },
    "attunement": null
  },
  "effects": [],
  "flags": {
    "ddbimporter": {
      "id": 138957,
      "definitionId": 2324,
      "entityTypeId": 435869154,
      "dndbeyond": {
        "lookup": "generic",
        "lookupName": "generic",
        "level": null,
        "castAtLevel": null
      },
      "originalName": "Wrathful Smite",
      "sources": [
        {
          "sourceId": 2,
          "pageNumber": 289,
          "sourceType": 1
        }
      ],
      "tags": [
        "Damage",
        "Control"
      ],
      "version": "2.9.64",
      "effectsApplied": true
    },
    "core": {
      "sourceId": "Compendium.world.ddb-spells-2.AZgt7YaYhGn4VpCr"
    },
    "scene-packer": {
      "hash": "2422168703771df1219539cb12404023be7176ae",
      "sourceId": "Item.4TKGf3P5YGEGcPnj"
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Wrathful Smite",
          "type": "script",
          "author": "otqBqyqMuTGDffTr",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "// wrathful smite\n\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nconst lastArg = args[args.length - 1];\nconst token = canvas.tokens.get(lastArg.tokenId);\nconst tokenOrActor = await fromUuid(lastArg.actorUuid);\nconst tactor = tokenOrActor.actor ? tokenOrActor.actor : tokenOrActor;\nconst sourceToken = canvas.tokens.get(args[1]);\nconst gameRound = game.combat ? game.combat.round : 0;\n\nasync function attemptRemoval(targetToken, condition, item) {\n    if (game.dfreds.effectInterface.hasEffectApplied(condition, targetToken.uuid)) {\n        new Dialog({\n        title: `Use action to attempt to remove ${condition}?`,\n        buttons: {\n            one: {\n            label: \"Yes\",\n            callback: async () => {\n                const caster = item.parent;\n                const saveDc = caster.data.data.attributes.spelldc;\n                const removalCheck = true;\n                const ability = \"wis\";\n                const type = removalCheck ? \"abil\" : \"save\";\n                const rollOptions = { chatMessage: true, fastForward: true };\n                const roll = await MidiQOL.socket().executeAsGM(\"rollAbility\", { request: type, targetUuid: targetToken.uuid, ability: ability, options: rollOptions });\n                if (game.dice3d) game.dice3d.showForRoll(roll);\n\n                if (roll.total >= saveDc) {\n                game.dfreds.effectInterface.removeEffect({ effectName: condition, uuid: targetToken.uuid });\n                } else {\n                if (roll.total < saveDc) ChatMessage.create({ content: `${targetToken.name} fails the roll for ${item.name}, still has the ${condition} condition.` });\n                }\n            },\n            },\n            two: {\n            label: \"No\",\n            callback: () => {},\n            },\n        },\n        }).render(true);\n    }\n}\n\n// canSee by tposney via midi-qol utils.js\nasync function canSee(tokenEntity, targetEntity) {\n\t//TODO - requires rewrite for v10\n\t//@ts-ignore\n\tlet target = targetEntity instanceof TokenDocument ? targetEntity.object : targetEntity;\n\t//@ts-ignore\n\tlet token = tokenEntity instanceof TokenDocument ? tokenEntity.object : tokenEntity;\n\tif (!token || !target)\n\t\treturn true;\n\tconst targetPoint = target.center;\n\tconst visionSource = token.vision;\n\tif (!token.vision.active)\n\t\treturn true; //TODO work out what to do with tokens with no vision\n\tconst lightSources = canvas?.lighting?.sources;\n\t// Determine the array of offset points to test\n\tconst t = Math.min(target.w, target.h) / 4;\n\tconst offsets = t > 0 ? [[0, 0], [-t, -t], [-t, t], [t, t], [t, -t], [-t, 0], [t, 0], [0, -t], [0, t]] : [[0, 0]];\n\tconst points = offsets.map(o => new PIXI.Point(targetPoint.x + o[0], targetPoint.y + o[1]));\n\t// If the point is entirely inside the buffer region, it may be hidden from view\n\t// if (!target._inBuffer && !points.some(p => canvas?.dimensions?.sceneRect.contains(p.x, p.y))) return false;\n\t// Check each point for one which provides both LOS and FOV membership\n\tconst returnValue = points.some(p => {\n\t\tlet hasLOS = false;\n\t\tlet hasFOV = false;\n\t\tlet requireFOV = !canvas?.lighting?.globalLight;\n\t\tif (!hasLOS || (!hasFOV && requireFOV)) { // Do we need to test for LOS?\n\t\t\tif (visionSource?.los?.contains(p.x, p.y)) {\n\t\t\t\thasLOS = true;\n\t\t\t\tif (!hasFOV && requireFOV) { // Do we need to test for FOV?\n\t\t\t\t\tif (visionSource?.fov?.contains(p.x, p.y))\n\t\t\t\t\t\thasFOV = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (hasLOS && (!requireFOV || hasFOV)) { // Did we satisfy all required conditions?\n\t\t\treturn true;\n\t\t}\n\t\t// Check light sources\n\t\tfor (let source of lightSources?.values() ?? []) {\n\t\t\tif (!source.active)\n\t\t\t\tcontinue;\n\t\t\t//@ts-ignore\n\t\t\tif (source.containsPoint(p)) {\n\t\t\t\t//@ts-ignore\n\t\t\t\tif (source.data.vision)\n\t\t\t\t\thasLOS = true;\n\t\t\t\thasFOV = true;\n\t\t\t}\n\t\t\tif (hasLOS && (!requireFOV || hasFOV))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t});\n\treturn returnValue;\n}\n\nasync function sightCheck(actorOrWorkflow, rollData) {\n    if (actorOrWorkflow.actor !== tactor && actorOrWorkflow !== tactor) return;\n    if (token && sourceToken) { \n        let canSeeSource = false;\n        if (game.modules.get(\"conditional-visibility\")?.active && game.modules.get(\"levels\")?.active && _levels) { \n            canSeeSource = game.modules.get('conditional-visibility')?.api?.canSee(token, sourceToken) && _levels?.advancedLosTestVisibility(token, sourceToken);\n        } else {\n            canSeeSource = canSee(token, sourceToken);\n        }\n        if (canSeeSource) {\n            if (rollData) {\n                Object.assign(rollData, { disadvantage: true });\n                return;\n            }\n            let ef = await tactor.effects.find(i => i.data === lastArg.efData);\n            let newChanges = [];\n            if (!ef.data.changes.find(c => c.key === \"flags.midi-qol.disadvantage.attack.all\")) newChanges.push({ key: \"flags.midi-qol.disadvantage.attack.all\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 0 });\n            if (!ef.data.changes.find(c => c.key === \"flags.midi-qol.disadvantage.ability.check.all\")) newChanges.push({ key: \"flags.midi-qol.disadvantage.ability.check.all\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 0 });\n            await ef.update({ changes: newChanges.concat(ef.data.changes) });\n            if (newChanges) {\n                newChanges = ef.data.changes.filter((c) => c.key !== \"flags.midi-qol.disadvantage.attack.all\" && c.key !== \"flags.midi-qol.disadvantage.ability.check.all\");\n                ef.update({ changes: newChanges });\n            }\n        } \n    }\n}\n\nif (lastArg.tag === \"OnUse\") {\n    let itemD = lastArg.item;\n    let itemName = game.i18n.localize(itemD.name);\n    let effectData = [{\n        changes: [\n            { key: \"flags.dnd5e.DamageBonusMacro\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: `ItemMacro.${itemName}`, priority: 20 },\n            { key: \"flags.midi-qol.spellId\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: lastArg.uuid, priority: 20 }\n        ],\n        origin: lastArg.uuid,\n        disabled: false,\n        duration: { rounds: 10, startRound: gameRound, startTime: game.time.worldTime },\n        flags: {\n            \"dae\": { itemData: itemD, specialDuration: [\"1Hit\"] }\n        },\n        icon: itemD.img,\n        label: itemName\n    }];\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: token.actor.uuid, effects: effectData });\n}\n\nif (lastArg.tag === \"DamageBonus\") {\n    if (![\"mwak\"].includes(lastArg.item.data.actionType) || lastArg.hitTargetUuids.length < 1) return {};\n    let tokenOrActorTarget = await fromUuid(lastArg.hitTargetUuids[0]);\n    let tactorTarget = tokenOrActorTarget.actor ? tokenOrActorTarget.actor : tokenOrActorTarget;\n    let spellDC = tactor.data.data.attributes.spelldc;\n    let conc = tactor.effects.find(i => i.data.label === game.i18n.localize(\"Concentrating\"));\n    let spellUuid = getProperty(tactor.data.flags, \"midi-qol.spellId\");\n    let spellItem = await fromUuid(getProperty(tactor.data.flags, \"midi-qol.spellId\"));\n    let itemName = game.i18n.localize(spellItem.name);\n    let damageType = \"psychic\";\n    let effectData = [{\n        changes: [\n            { key: `macro.itemMacro.GM`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: lastArg.tokenId, priority: 20 },\n            { key: `flags.dae.deleteUuid`, mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: conc.uuid, priority: 20 }\n        ],\n        origin: spellUuid,\n        flags: {\n            \"dae\": { itemData: spellItem.data, token: tactorTarget.uuid, macroRepeat: \"startEveryTurn\" },\n            \"core\": { statusId: \"Frightened\" }\n        },\n        disabled: false,\n        duration: { rounds: 10, startRound: gameRound, startTime: game.time.worldTime },\n        icon: \"icons/svg/terror.svg\",\n        label: \"Frightened\"\n    }];\n\n    if (conc) {\n        const resist = [\"Brave\", \"Fear Resilience\"];\n        const getResist = tactorTarget.items.find(i => resist.includes(i.name));\n        const rollOptions = getResist ? { chatMessage: true, fastForward: true, advantage: true } : { chatMessage: true, fastForward: true };\n        const roll = await MidiQOL.socket().executeAsGM(\"rollAbility\", { request: \"save\", targetUuid: tactorTarget.uuid, ability: \"wis\", options: rollOptions });\n        if (game.dice3d) game.dice3d.showForRoll(roll);\n        if (roll.total < spellDC) {\n            await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: tactorTarget.uuid, effects: effectData });\n        }\n        let concUpdate = await getProperty(tactor.data.flags, \"midi-qol.concentration-data.targets\");\n        await concUpdate.push({ tokenUuid: tokenOrActorTarget.uuid, actorUuid: tactorTarget.uuid });\n        await tactor.setFlag(\"midi-qol\", \"concentration-data.targets\", concUpdate);\n    }\n\n    const diceMult = args[0].isCritical ? 2: 1;\n    return { damageRoll: `${diceMult}d6[${damageType}]`, flavor: `(${itemName} (${CONFIG.DND5E.damageTypes[damageType]}))` };\n}\n\nif (args[0] === \"on\" && token !== sourceToken) {\n    if (game.modules.get(\"midi-qol\")?.active) {\n    let hookId1 = Hooks.on(\"midi-qol.preItemRoll\", sightCheck);\n    DAE.setFlag(tactor, \"fearAtkHook\", hookId1);\n    }\n    \n    if (game.modules.get(\"more-hooks-5e\")?.active) {\n    let hookId2 = Hooks.on(\"Actor5e.preRollAbilityTest\", sightCheck);\n    DAE.setFlag(tactor, \"fearAblHook\", hookId2);\n\n    let hookId3 = Hooks.on(\"Actor5e.preRollSkill\", sightCheck);\n    DAE.setFlag(tactor, \"fearSklHook\", hookId3);\n    }\n}\n\nif (args[0] === \"each\" && lastArg.efData.disabled === false && token !== sourceToken) {\n    const targetToken = await fromUuid(lastArg.tokenUuid);\n    const condition = \"Frightened\";\n    const item = await fromUuid(lastArg.efData.origin);\n    attemptRemoval(targetToken, condition, item);\n}\n\nif (args[0] === \"off\" && token !== sourceToken) {\n    const flag1 = await DAE.getFlag(tactor, \"fearAtkHook\");\n\tif (flag1) {\n\t\tHooks.off(\"midi-qol.preItemRoll\", flag1);\n\t\tawait DAE.unsetFlag(tactor, \"fearAtkHook\");\n\t}\n    \n    const flag2 = await DAE.getFlag(tactor, \"fearAblHook\");\n\tif (flag2) {\n\t\tHooks.off(\"Actor5e.preRollAbilityTest\", flag2);\n\t\tawait DAE.unsetFlag(tactor, \"fearAblHook\");\n\t}\n    \n    const flag3 = await DAE.getFlag(tactor, \"fearSklHook\");\n\tif (flag3) {\n\t\tHooks.off(\"Actor5e.preRollSkill\", flag3);\n\t\tawait DAE.unsetFlag(tactor, \"fearSklHook\");\n\t}\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        },
        "_id": null,
        "name": "Wrathful Smite",
        "type": "script",
        "author": "ckiTPzlaPztdkjV6",
        "img": "icons/svg/dice-target.svg",
        "scope": "global",
        "command": "// wrathful smite\n\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nconst lastArg = args[args.length - 1];\nconst token = canvas.tokens.get(lastArg.tokenId);\nconst tokenOrActor = await fromUuid(lastArg.actorUuid);\nconst tactor = tokenOrActor.actor ? tokenOrActor.actor : tokenOrActor;\nconst sourceToken = canvas.tokens.get(args[1]);\nconst gameRound = game.combat ? game.combat.round : 0;\n\nasync function attemptRemoval(targetToken, condition, item) {\n    if (game.dfreds.effectInterface.hasEffectApplied(condition, targetToken.uuid)) {\n        new Dialog({\n        title: `Use action to attempt to remove ${condition}?`,\n        buttons: {\n            one: {\n            label: \"Yes\",\n            callback: async () => {\n                const caster = item.parent;\n                const saveDc = caster.data.data.attributes.spelldc;\n                const removalCheck = true;\n                const ability = \"wis\";\n                const type = removalCheck ? \"abil\" : \"save\";\n                const rollOptions = { chatMessage: true, fastForward: true };\n                const roll = await MidiQOL.socket().executeAsGM(\"rollAbility\", { request: type, targetUuid: targetToken.uuid, ability: ability, options: rollOptions });\n                if (game.dice3d) game.dice3d.showForRoll(roll);\n\n                if (roll.total >= saveDc) {\n                    let fear = tactor.effects.find(i => i.data === lastArg.efData);\n\t\t            if (fear) await tactor.deleteEmbeddedDocuments(\"ActiveEffect\", [fear.id]);\n                } else {\n                    if (roll.total < saveDc) ChatMessage.create({ content: `${targetToken.name} fails the roll for ${item.name}, still has the ${condition} condition.` });\n                }\n            },\n            },\n            two: {\n            label: \"No\",\n            callback: () => {},\n            },\n        },\n        }).render(true);\n    }\n}\n\n// canSee by tposney via midi-qol utils.js\nasync function canSee(tokenEntity, targetEntity) {\n\t//TODO - requires rewrite for v10\n\t//@ts-ignore\n\tlet target = targetEntity instanceof TokenDocument ? targetEntity.object : targetEntity;\n\t//@ts-ignore\n\tlet token = tokenEntity instanceof TokenDocument ? tokenEntity.object : tokenEntity;\n\tif (!token || !target)\n\t\treturn true;\n\tconst targetPoint = target.center;\n\tconst visionSource = token.vision;\n\tif (!token.vision.active)\n\t\treturn true; //TODO work out what to do with tokens with no vision\n\tconst lightSources = canvas?.lighting?.sources;\n\t// Determine the array of offset points to test\n\tconst t = Math.min(target.w, target.h) / 4;\n\tconst offsets = t > 0 ? [[0, 0], [-t, -t], [-t, t], [t, t], [t, -t], [-t, 0], [t, 0], [0, -t], [0, t]] : [[0, 0]];\n\tconst points = offsets.map(o => new PIXI.Point(targetPoint.x + o[0], targetPoint.y + o[1]));\n\t// If the point is entirely inside the buffer region, it may be hidden from view\n\t// if (!target._inBuffer && !points.some(p => canvas?.dimensions?.sceneRect.contains(p.x, p.y))) return false;\n\t// Check each point for one which provides both LOS and FOV membership\n\tconst returnValue = points.some(p => {\n\t\tlet hasLOS = false;\n\t\tlet hasFOV = false;\n\t\tlet requireFOV = !canvas?.lighting?.globalLight;\n\t\tif (!hasLOS || (!hasFOV && requireFOV)) { // Do we need to test for LOS?\n\t\t\tif (visionSource?.los?.contains(p.x, p.y)) {\n\t\t\t\thasLOS = true;\n\t\t\t\tif (!hasFOV && requireFOV) { // Do we need to test for FOV?\n\t\t\t\t\tif (visionSource?.fov?.contains(p.x, p.y))\n\t\t\t\t\t\thasFOV = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (hasLOS && (!requireFOV || hasFOV)) { // Did we satisfy all required conditions?\n\t\t\treturn true;\n\t\t}\n\t\t// Check light sources\n\t\tfor (let source of lightSources?.values() ?? []) {\n\t\t\tif (!source.active)\n\t\t\t\tcontinue;\n\t\t\t//@ts-ignore\n\t\t\tif (source.containsPoint(p)) {\n\t\t\t\t//@ts-ignore\n\t\t\t\tif (source.data.vision)\n\t\t\t\t\thasLOS = true;\n\t\t\t\thasFOV = true;\n\t\t\t}\n\t\t\tif (hasLOS && (!requireFOV || hasFOV))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t});\n\treturn returnValue;\n}\n\nasync function sightCheck(actorOrWorkflow, rollData) {\n    if (actorOrWorkflow.actor !== tactor && actorOrWorkflow !== tactor) return;\n    if (token && sourceToken) { \n        let canSeeSource = false;\n        if (game.modules.get(\"conditional-visibility\")?.active && game.modules.get(\"levels\")?.active && _levels) { \n            canSeeSource = game.modules.get('conditional-visibility')?.api?.canSee(token, sourceToken) && _levels?.advancedLosTestVisibility(token, sourceToken);\n        } else {\n            canSeeSource = canSee(token, sourceToken);\n        }\n        if (canSeeSource) {\n            if (rollData) {\n                Object.assign(rollData, { disadvantage: true });\n                return;\n            }\n            let ef = await tactor.effects.find(i => i.data === lastArg.efData);\n            let newChanges = [];\n            if (!ef.data.changes.find(c => c.key === \"flags.midi-qol.disadvantage.attack.all\")) newChanges.push({ key: \"flags.midi-qol.disadvantage.attack.all\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 0 });\n            if (!ef.data.changes.find(c => c.key === \"flags.midi-qol.disadvantage.ability.check.all\")) newChanges.push({ key: \"flags.midi-qol.disadvantage.ability.check.all\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 0 });\n            await ef.update({ changes: newChanges.concat(ef.data.changes) });\n            if (newChanges) {\n                newChanges = ef.data.changes.filter((c) => c.key !== \"flags.midi-qol.disadvantage.attack.all\" && c.key !== \"flags.midi-qol.disadvantage.ability.check.all\");\n                ef.update({ changes: newChanges });\n            }\n        } \n    }\n}\n\nif (lastArg.tag === \"OnUse\") {\n    let itemD = lastArg.item;\n    let itemName = game.i18n.localize(itemD.name);\n    let effectData = [{\n        changes: [\n            { key: \"flags.dnd5e.DamageBonusMacro\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: `ItemMacro.${itemName}`, priority: 20 },\n            { key: \"flags.midi-qol.spellId\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: lastArg.uuid, priority: 20 }\n        ],\n        origin: lastArg.uuid,\n        disabled: false,\n        duration: { rounds: 10, startRound: gameRound, startTime: game.time.worldTime },\n        flags: {\n            \"dae\": { itemData: itemD, specialDuration: [\"1Hit\"] }\n        },\n        icon: itemD.img,\n        label: itemName\n    }];\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: token.actor.uuid, effects: effectData });\n}\n\nif (lastArg.tag === \"DamageBonus\") {\n    if (![\"mwak\"].includes(lastArg.item.data.actionType) || lastArg.hitTargetUuids.length < 1) return {};\n    let tokenOrActorTarget = await fromUuid(lastArg.hitTargetUuids[0]);\n    let tactorTarget = tokenOrActorTarget.actor ? tokenOrActorTarget.actor : tokenOrActorTarget;\n    let spellDC = tactor.data.data.attributes.spelldc;\n    let conc = tactor.effects.find(i => i.data.label === game.i18n.localize(\"Concentrating\"));\n    let spellUuid = getProperty(tactor.data.flags, \"midi-qol.spellId\");\n    let spellItem = await fromUuid(getProperty(tactor.data.flags, \"midi-qol.spellId\"));\n    let itemName = game.i18n.localize(spellItem.name);\n    let damageType = \"psychic\";\n    let effectData = [{\n        changes: [\n            { key: `macro.itemMacro.GM`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: lastArg.tokenId, priority: 20 },\n            { key: `flags.dae.deleteUuid`, mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: conc.uuid, priority: 20 }\n        ],\n        origin: spellUuid,\n        flags: {\n            \"dae\": { itemData: spellItem.data, token: tactorTarget.uuid, macroRepeat: \"startEveryTurn\" },\n            \"core\": { statusId: \"Frightened\" }\n        },\n        disabled: false,\n        duration: { rounds: 10, startRound: gameRound, startTime: game.time.worldTime },\n        icon: \"icons/svg/terror.svg\",\n        label: \"Frightened\"\n    }];\n\n    if (conc) {\n        const resist = [\"Brave\", \"Fear Resilience\"];\n        const getResist = tactorTarget.items.find(i => resist.includes(i.name));\n        const rollOptions = getResist ? { chatMessage: true, fastForward: true, advantage: true } : { chatMessage: true, fastForward: true };\n        const roll = await MidiQOL.socket().executeAsGM(\"rollAbility\", { request: \"save\", targetUuid: tactorTarget.uuid, ability: \"wis\", options: rollOptions });\n        if (game.dice3d) game.dice3d.showForRoll(roll);\n        if (roll.total < spellDC) {\n            await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: tactorTarget.uuid, effects: effectData });\n        }\n        let concUpdate = await getProperty(tactor.data.flags, \"midi-qol.concentration-data.targets\");\n        await concUpdate.push({ tokenUuid: tokenOrActorTarget.uuid, actorUuid: tactorTarget.uuid });\n        await tactor.setFlag(\"midi-qol\", \"concentration-data.targets\", concUpdate);\n    }\n\n    const diceMult = args[0].isCritical ? 2: 1;\n    return { damageRoll: `${diceMult}d6[${damageType}]`, flavor: `(${itemName} (${CONFIG.DND5E.damageTypes[damageType]}))` };\n}\n\nif (args[0] === \"on\" && token !== sourceToken) {\n    if (game.modules.get(\"midi-qol\")?.active) {\n    let hookId1 = Hooks.on(\"midi-qol.preItemRoll\", sightCheck);\n    DAE.setFlag(tactor, \"fearAtkHook\", hookId1);\n    }\n    \n    if (game.modules.get(\"more-hooks-5e\")?.active) {\n    let hookId2 = Hooks.on(\"Actor5e.preRollAbilityTest\", sightCheck);\n    DAE.setFlag(tactor, \"fearAblHook\", hookId2);\n\n    let hookId3 = Hooks.on(\"Actor5e.preRollSkill\", sightCheck);\n    DAE.setFlag(tactor, \"fearSklHook\", hookId3);\n    }\n}\n\nif (args[0] === \"each\" && lastArg.efData.disabled === false && token !== sourceToken) {\n    const targetToken = await fromUuid(lastArg.tokenUuid);\n    const condition = \"Frightened\";\n    const item = await fromUuid(lastArg.efData.origin);\n    attemptRemoval(targetToken, condition, item);\n}\n\nif (args[0] === \"off\" && token !== sourceToken) {\n    const flag1 = await DAE.getFlag(tactor, \"fearAtkHook\");\n\tif (flag1) {\n\t\tHooks.off(\"midi-qol.preItemRoll\", flag1);\n\t\tawait DAE.unsetFlag(tactor, \"fearAtkHook\");\n\t}\n    \n    const flag2 = await DAE.getFlag(tactor, \"fearAblHook\");\n\tif (flag2) {\n\t\tHooks.off(\"Actor5e.preRollAbilityTest\", flag2);\n\t\tawait DAE.unsetFlag(tactor, \"fearAblHook\");\n\t}\n    \n    const flag3 = await DAE.getFlag(tactor, \"fearSklHook\");\n\tif (flag3) {\n\t\tHooks.off(\"Actor5e.preRollSkill\", flag3);\n\t\tawait DAE.unsetFlag(tactor, \"fearSklHook\");\n\t}\n}",
        "folder": null,
        "sort": 0,
        "permission": {
          "default": 0
        },
        "flags": {}
      }
    },
    "rest-recovery": {
      "data": {
        "recovery": {
          "enabled": false
        }
      }
    },
    "midi-qol": {
      "effectActivation": false,
      "onUseMacroName": "[postActiveEffects]ItemMacro"
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "exportSource": {
      "world": "dnd5e",
      "system": "dnd5e",
      "coreVersion": "9.280",
      "systemVersion": "1.6.3"
    }
  }
}
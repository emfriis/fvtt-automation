{
  "name": "Arms of Hadar",
  "type": "spell",
  "img": "icons/commodities/biological/tentacle-purple-white.webp",
  "data": {
    "description": {
      "value": "<p>You invoke the power of Hadar, the Dark Hunger. Tendrils of dark energy erupt from you and batter all creatures within 10 feet of you. Each creature in that area must make a Strength saving throw. On a failed save, a target takes 2d6 necrotic damage and can’t take reactions until its next turn. On a successful save, the creature takes half damage, but suffers no other effect. </p>\n<p><strong>At Higher Levels. </strong>When you cast this spell using a spell slot of 2nd level or higher, the damage increases by 1d6 for each slot level above 1st.</p>",
      "chat": "",
      "unidentified": ""
    },
    "source": "Player's Handbook pg 215",
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": null,
      "units": "inst"
    },
    "target": {
      "value": null,
      "width": null,
      "units": "",
      "type": ""
    },
    "range": {
      "value": null,
      "long": null,
      "units": ""
    },
    "uses": {
      "value": null,
      "max": "",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "util",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": ""
    },
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell"
    },
    "level": 1,
    "school": "con",
    "components": {
      "value": "",
      "vocal": true,
      "somatic": true,
      "material": false,
      "ritual": false,
      "concentration": false
    },
    "materials": {
      "value": "",
      "consumed": false,
      "cost": 0,
      "supply": 0
    },
    "preparation": {
      "mode": "prepared",
      "prepared": false
    },
    "scaling": {
      "mode": "none",
      "formula": ""
    },
    "attunement": 0
  },
  "effects": [],
  "flags": {
    "ddbimporter": {
      "id": 136067,
      "definitionId": 2311,
      "entityTypeId": 435869154,
      "dndbeyond": {
        "lookup": "generic",
        "lookupName": "generic",
        "level": null,
        "castAtLevel": null
      },
      "originalName": "Arms of Hadar",
      "sources": [
        {
          "sourceId": 2,
          "pageNumber": 215,
          "sourceType": 1
        }
      ],
      "tags": [
        "Damage",
        "Control"
      ],
      "version": "2.9.59",
      "effectsApplied": true
    },
    "betterRolls5e": {
      "quickVersatile": {
        "altValue": true
      },
      "quickCharges": {
        "value": {
          "use": true,
          "resource": true
        },
        "altValue": {
          "use": true,
          "resource": true
        }
      }
    },
    "core": {
      "sourceId": "Compendium.world.ddb-spells.resxG5QnsHniBe1x"
    },
    "rest-recovery": {
      "data": {
        "recovery": {
          "enabled": false
        }
      }
    },
    "midi-qol": {
      "effectActivation": false,
      "onUseMacroName": "[postActiveEffects]ItemMacro"
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Arms of Hadar",
          "type": "script",
          "author": "otqBqyqMuTGDffTr",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "// arms of hadar\n\n// Midi-Qol On Use Macro\n// Let the macro do the saving throw and damage. Just assign Action type as Utility\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\n(async () => {\n    let tokenD = canvas.tokens.get(args[0].tokenId);\n    let actorD = game.actors.get(args[0].actor._id);\n    let distance = 10;\n    let itemD = args[0].item;\n    let dc = await actorD.getRollData().attributes.spelldc;\n    let get_target = canvas.tokens.placeables.filter(target => (MidiQOL.getDistance(tokenD, target, false) <= distance && tokenD.id != target.id && !canvas.walls.checkCollision(new Ray(tokenD.center, target.center))));\n    let numDice = 1+ args[0].spellLevel;\n    let damageRoll = new Roll(`${numDice}d6`).evaluate({ async: false });\n    let abilitySave = \"str\";\n    let saveName = CONFIG.DND5E.abilities[abilitySave];\n    game.dice3d?.showForRoll(damageRoll);\n    let damageResult = [];\n    let hitTargets = [];\n\tlet halfHitTargets = [];\n    for (let target of get_target) {\n        let save;\n        await target.actor.hasPlayerOwner ? save = await target.actor.rollAbilitySave(abilitySave, { chatMessage: false }) : save = await target.actor.rollAbilitySave(abilitySave, { chatMessage: false, fastForward: true });\n        game.dice3d?.showForRoll(save);\n        if (save.total >= dc) {\n            damageResult.push(`<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\"> Target saves </div><div><img src=\"${target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`);\n\t\t\thalfHitTargets.push(target);\n\n        } else {\n            damageResult.push(`<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\"> Target fails </div><div><img src=\"${target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`);\n            hitTargets.push(target);\n        }\n    }\n    new MidiQOL.DamageOnlyWorkflow(actorD, tokenD, damageRoll.total, \"necrotic\", hitTargets, damageRoll, { flavor: `(Necrotic)`, itemCardId: args[0].itemCardId });\n\tnew MidiQOL.DamageOnlyWorkflow(actorD, tokenD, Math.floor(damageRoll.total/2), \"necrotic\", halfHitTargets, damageRoll, { flavor: `(Necrotic)`, itemCardId: args[0].itemCardId });\n    let damageList = damageResult.join('');\n    await wait(1000);\n    let damage_results = `<div class=\"midi-qol-nobox midi-qol-bigger-text\">${itemD.name} DC ${dc} ${saveName} Saving Throw:</div><div><div class=\"midi-qol-nobox\">${damageList}</div></div>`;\n    const chatMessage = await game.messages.get(args[0].itemCardId);\n    let content = await duplicate(chatMessage.data.content);\n    const searchString = /<div class=\"midi-qol-hits-display\">[\\s\\S]*<div class=\"end-midi-qol-hits-display\">/g;\n    const replaceString = `<div class=\"midi-qol-hits-display\"><div class=\"end-midi-qol-hits-display\">${damage_results}`;\n    content = await content.replace(searchString, replaceString);\n    await chatMessage.update({ content: content });\n})();",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        },
        "_id": null,
        "name": "Arms of Hadar",
        "type": "script",
        "author": "ckiTPzlaPztdkjV6",
        "img": "icons/svg/dice-target.svg",
        "scope": "global",
        "command": "// arms of hadar\n\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\n(async () => {\n    let tokenD = canvas.tokens.get(args[0].tokenId);\n    let actorD = game.actors.get(args[0].actor._id);\n    let distance = 10;\n    let itemD = args[0].item;\n    let dc = await actorD.getRollData().attributes.spelldc;\n    let get_target = canvas.tokens.placeables.filter(target => (MidiQOL.getDistance(tokenD, target, false) <= distance && tokenD.id != target.id && !canvas.walls.checkCollision(new Ray(tokenD.center, target.center))));\n    let numDice = 1+ args[0].spellLevel;\n    let damageRoll = new Roll(`${numDice}d6`).evaluate({ async: false });\n    let abilitySave = \"str\";\n    let saveName = CONFIG.DND5E.abilities[abilitySave];\n    game.dice3d?.showForRoll(damageRoll);\n    let damageResult = [];\n    let hitTargets = [];\n\tlet halfHitTargets = [];\n    for (let target of get_target) {\n        let save;\n        await target.actor.hasPlayerOwner ? save = await target.actor.rollAbilitySave(abilitySave, { chatMessage: false }) : save = await target.actor.rollAbilitySave(abilitySave, { chatMessage: false, fastForward: true });\n        game.dice3d?.showForRoll(save);\n        if (save.total >= dc) {\n            damageResult.push(`<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\"> Target saves </div><div><img src=\"${target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`);\n\t\t\thalfHitTargets.push(target);\n\n        } else {\n            damageResult.push(`<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\"> Target fails </div><div><img src=\"${target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`);\n            hitTargets.push(target);\n        }\n    }\n    new MidiQOL.DamageOnlyWorkflow(actorD, tokenD, damageRoll.total, \"necrotic\", hitTargets, damageRoll, { flavor: `(Necrotic)`, itemCardId: args[0].itemCardId });\n\tnew MidiQOL.DamageOnlyWorkflow(actorD, tokenD, Math.floor(damageRoll.total/2), \"necrotic\", halfHitTargets, damageRoll, { flavor: `(Necrotic)`, itemCardId: args[0].itemCardId });\n    let damageList = damageResult.join('');\n    await wait(1000);\n    let damage_results = `<div class=\"midi-qol-nobox midi-qol-bigger-text\">${itemD.name} DC ${dc} ${saveName} Saving Throw:</div><div><div class=\"midi-qol-nobox\">${damageList}</div></div>`;\n    const chatMessage = await game.messages.get(args[0].itemCardId);\n    let content = await duplicate(chatMessage.data.content);\n    const searchString = /<div class=\"midi-qol-hits-display\">[\\s\\S]*<div class=\"end-midi-qol-hits-display\">/g;\n    const replaceString = `<div class=\"midi-qol-hits-display\"><div class=\"end-midi-qol-hits-display\">${damage_results}`;\n    content = await content.replace(searchString, replaceString);\n    await chatMessage.update({ content: content });\n})();",
        "folder": null,
        "sort": 0,
        "permission": {
          "default": 0
        },
        "flags": {}
      }
    },
    "scene-packer": {
      "sourceId": "Item.OZ0iHnLHD5LrPfs6",
      "hash": "7c5d3bb42cba089e57df1a2ee7f488886ab7cb3b"
    },
    "exportSource": {
      "world": "dnd5e",
      "system": "dnd5e",
      "coreVersion": "9.280",
      "systemVersion": "1.6.3"
    }
  }
}
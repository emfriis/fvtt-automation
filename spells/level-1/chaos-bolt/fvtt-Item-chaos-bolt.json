{
  "name": "Chaos Bolt",
  "type": "spell",
  "img": "icons/magic/lightning/bolt-strike-beam-purple.webp",
  "data": {
    "description": {
      "value": "<p>You hurl an undulating, warbling mass of chaotic energy at one creature in range. Make a ranged spell attack against the target. On a hit, the target takes 2d8 + 1d6 damage. Choose one of the d8s. The number rolled on that die determines the attack’s damage type, as shown below.</p>\n<div class=\"table-overflow-wrapper\">\n<table class=\"compendium-left-aligned-table\">\n<thead>\n<tr>\n<th>d8</th>\n<th>Damage Type</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Acid</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Cold</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Fire</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Force</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Lightning</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Poison</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Psychic</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Thunder</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>If you roll the same number on both d8s, the chaotic energy leaps from the target to a different creature of your choice within 30 feet of it. Make a new attack roll against the new target, and make a new damage roll, which could cause the chaotic energy to leap again.</p>\n<p>A creature can be targeted only once by each casting of this spell.</p>\n<p><strong><em>At Higher Levels.</em></strong> When you cast this spell using a spell slot of 2nd level or higher, each target takes 1d6 extra damage of the type rolled for each slot level above 1st.</p>",
      "chat": "<p>You hurl an undulating, warbling mass of chaotic energy at one creature in range. Make a ranged spell attack against the target. On a hit, the target takes 2d8 + 1d6 damage. Choose one of the d8s. The number rolled on that die determines the attack’s damage type, as shown below.</p>\n<div class=\"table-overflow-wrapper\">\n<table class=\"compendium-left-aligned-table\">\n<thead>\n<tr>\n<th>d8</th>\n<th>Damage Type</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Acid</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Cold</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Fire</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Force</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Lightning</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Poison</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Psychic</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Thunder</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>If you roll the same number on both d8s, the chaotic energy leaps from the target to a different creature of your choice within 30 feet of it. Make a new attack roll against the new target, and make a new damage roll, which could cause the chaotic energy to leap again.</p>\n<p>A creature can be targeted only once by each casting of this spell.</p>\n<p><strong><em>At Higher Levels.</em></strong> When you cast this spell using a spell slot of 2nd level or higher, each target takes 1d6 extra damage of the type rolled for each slot level above 1st.</p>",
      "unidentified": ""
    },
    "source": "Xanathar's Guide to Everything pg 151",
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": null,
      "units": ""
    },
    "target": {
      "value": 1,
      "width": null,
      "units": "",
      "type": "creature"
    },
    "range": {
      "value": 120,
      "long": null,
      "units": "ft"
    },
    "uses": {
      "value": 0,
      "max": "0",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "rsak",
    "attackBonus": "0",
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": ""
    },
    "damage": {
      "parts": [],
      "versatile": "",
      "value": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell"
    },
    "level": 1,
    "school": "evo",
    "components": {
      "value": "",
      "vocal": true,
      "somatic": true,
      "material": false,
      "ritual": false,
      "concentration": false
    },
    "materials": {
      "value": "",
      "consumed": false,
      "cost": 0,
      "supply": 0
    },
    "preparation": {
      "mode": "prepared",
      "prepared": false
    },
    "scaling": {
      "mode": "level",
      "formula": "1d6"
    },
    "attunement": null
  },
  "effects": [],
  "flags": {
    "ddbimporter": {
      "id": 154574,
      "definitionId": 14761,
      "entityTypeId": 435869154,
      "dndbeyond": {
        "lookup": "generic",
        "lookupName": "generic",
        "level": null,
        "castAtLevel": null
      },
      "sources": [
        {
          "sourceId": 27,
          "pageNumber": 151,
          "sourceType": 1
        }
      ],
      "tags": [
        "Damage"
      ]
    },
    "betterRolls5e": {
      "quickVersatile": {
        "altValue": true
      },
      "quickCharges": {
        "value": {
          "use": true,
          "resource": true
        },
        "altValue": {
          "use": true,
          "resource": true
        }
      }
    },
    "core": {
      "sourceId": "Compendium.world.ddb-darklands-spells.tkAlk8aLVESjnknR"
    },
    "midi-qol": {
      "criticalThreshold": "20",
      "onUseMacroName": "[postActiveEffects]ItemMacro",
      "forceCEOn": false,
      "effectActivation": false,
      "fumbleThreshold": null
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Chaos Bolt",
          "type": "script",
          "author": "Tyd5yiqWrRZMvG30",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "// Macro written by Crymic : goto https://www.patreon.com/crymic for more!\nconst lastArg = args[args.length - 1];\nconst damageList = { 1: \"acid\", 2: \"cold\", 3: \"fire\", 4: \"force\", 5: \"lightning\", 6: \"poison\", 7: \"psychic\", 8: \"thunder\" };\nconst actorD = game.actors.get(lastArg.actor._id);\nconst tokenD = canvas.tokens.get(lastArg.tokenId);\nconst itemD = lastArg.item;\nconst spellLevel = Number(lastArg.spellLevel);\nconst upcast = spellLevel;\nlet target;\n\nif (lastArg.hitTargets.length > 0) {\n  target = canvas.tokens.get(lastArg.hitTargets[0].id);\n  await dealDamage(target, null, null, itemD);  \n} else {\n  target = canvas.tokens.get(lastArg.targets[0].id);  \n}\n\nasync function findTarget(target, itemD) {\n  let get_targets = await MidiQOL.findNearby(CONST.TOKEN_DISPOSITIONS.FRIENDLY, target, 30, null);\n  await rollAttack(get_targets, itemD);\n}\n\nasync function rollAttack(get_targets, itemD) {\n  let targetList;\n  for (let target of get_targets) {\n    targetList += `<option value=\"${target.id}\">${target.name}</option>`;\n  }\n  let dialog = new Promise((resolve) => {\n  new Dialog({\n    title: `${itemD.name} : New Target`,\n    content: `<form><div class=\"form-group\"><label for=\"target\">Pick Target</label><select id=\"target\">${targetList}</select></div></form>`,\n    buttons: {\n      attack: {\n        label: \"Attack\",\n        callback: async (html) => {\n          let find_target = html.find('#target').val();\n          let get_target = canvas.tokens.get(find_target);\n          await get_target.setTarget(true, { releaseOthers: true });\n          let roll = actorD.items.get(itemD._id).rollAttack();\n          if (roll.total >= get_target.actor.data.data.attributes.ac.value) {\n            const newCritical = roll.terms[0].total === 20 ? true : false;\n            await dealDamage(get_target, 1, newCritical, itemD);           \n          }\n          resolve();\n        }\n      }\n    },\n    default: \"attack\"\n  }).render(true);\n  });\n  await dialog;\n}\n\nasync function dealDamage(target, reCast, newCritical, itemD) { \n  let numDice = newCritical ? `1d8 + 1d8 + 2d8 + ${upcast * 2}d6` : lastArg.isCritical ? `1d8 + 1d8 + 2d8 + ${upcast * 2}d6` : `1d8 + 1d8 + ${upcast}d6`;\n  let damageRoll = new Roll(`${numDice}`).evaluate({ async: false });\n  let firstElement = damageList[damageRoll.terms[0].total];\n  let secondElement = damageList[damageRoll.terms[2].total];\n  let selectElement;\n  let castAgain = 0;\n  let elementList = [];\n  if (firstElement != secondElement) {\n    elementList.push(firstElement);\n    elementList.push(secondElement);\n    castAgain = 0;\n  } else {\n    elementList = firstElement;\n    castAgain = 1;\n  }\n  for (let element of elementList) {\n    selectElement += `<option value=\"${element}\">${element}</option>`;\n  }\n  if (firstElement === secondElement) {\n    damageRoll.terms[0].options.flavor = elementList;\n    damageRoll.terms[2].options.flavor = elementList;\n    damageRoll.terms[4].options.flavor = elementList;\n    lastArg.isCritical ? damageRoll.terms[6].options.flavor = elementList : \"\";\n    game.dice3d?.showForRoll(damageRoll);\n    if (reCast === 1) {\n      let msgHistory = game.messages.filter(i => i.data.flavor === itemD.name && i.data.speaker.token === tokenD.id);\n      let lastMessage = msgHistory.pop();\n      let newId = lastMessage.data._id;\n      await workflowDamage(damageRoll, elementList, target, newId, itemD);\n    } else {\n      await workflowDamage(damageRoll, elementList, target, lastArg.itemCardId, itemD);      \n    }\n    if (castAgain === 1) {\n      await findTarget(target, itemD);\n    }\n  } else {\n    let the_message = `<form><div class=\"form-group\"><label for=\"element\">Pick Element</label><select id=\"element\">${selectElement}</select></div></form>`;\n    let dialog = new Promise((resolve) => {\n    new Dialog({\n      title: itemD.name,\n      content: the_message,\n      buttons: {\n        damage: {\n          label: \"Damage\",\n          callback: async (html) => {\n            let element = html.find('#element').val();\n            damageRoll.terms[0].options.flavor = element;\n            damageRoll.terms[2].options.flavor = element;\n            damageRoll.terms[4].options.flavor = element;\n            lastArg.isCritical ? damageRoll.terms[6].options.flavor = element : \"\";\n            game.dice3d?.showForRoll(damageRoll);\n            if (reCast === 1) {\n              let msgHistory = game.messages.filter(i => i.data.flavor === itemD.name && i.data.speaker.token === tokenD.id);\n              let lastMessage = msgHistory.pop();\n              let newId = lastMessage.data._id;              \n              await workflowDamage(damageRoll, element, target, newId, itemD);\n            } else {\n              await workflowDamage(damageRoll, element, target, lastArg.itemCardId, itemD);\n            }\n            resolve();\n          }\n        }\n      },\n      default: \"damage\"\n    }).render(true);\n  });\n  await dialog;\n  }\n}\n\nasync function workflowDamage(damageRoll, element, target, cardId, itemD) {  \n  let damageWorkflow = await new MidiQOL.DamageOnlyWorkflow(actorD, tokenD, damageRoll.total, element, [target], damageRoll, { flavor: `(${element})`, itemCardId: cardId, itemData: itemD, useOther: false });\n  let damageBonusMacro = getProperty(actorD.data.flags, `${game.system.id}.DamageBonusMacro`);\n  if (damageBonusMacro) {\n    await damageWorkflow.rollBonusDamage(damageBonusMacro);\n  } else {\n    await damageWorkflow;\n  }\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        },
        "_id": null,
        "name": "Chaos Bolt",
        "type": "script",
        "author": "ckiTPzlaPztdkjV6",
        "img": "icons/svg/dice-target.svg",
        "scope": "global",
        "command": "// Macro written by Crymic : goto https://www.patreon.com/crymic for more!\nconst lastArg = args[args.length - 1];\nconst damageList = { 1: \"acid\", 2: \"cold\", 3: \"fire\", 4: \"force\", 5: \"lightning\", 6: \"poison\", 7: \"psychic\", 8: \"thunder\" };\nconst actorD = game.actors.get(lastArg.actor._id);\nconst tokenD = canvas.tokens.get(lastArg.tokenId);\nconst itemD = lastArg.item;\nconst spellLevel = Number(lastArg.spellLevel);\nconst upcast = spellLevel;\nlet target;\n\nif (lastArg.hitTargets.length > 0) {\n  target = canvas.tokens.get(lastArg.hitTargets[0].id);\n  await dealDamage(target, null, null, itemD);  \n} else {\n  target = canvas.tokens.get(lastArg.targets[0].id);  \n}\n\nasync function findTarget(target, itemD) {\n  let get_targets = await MidiQOL.findNearby(CONST.TOKEN_DISPOSITIONS.FRIENDLY, target, 30, null);\n  await rollAttack(get_targets, itemD);\n}\n\nasync function rollAttack(get_targets, itemD) {\n  let targetList;\n  for (let target of get_targets) {\n    targetList += `<option value=\"${target.id}\">${target.name}</option>`;\n  }\n  let dialog = new Promise((resolve) => {\n  new Dialog({\n    title: `${itemD.name} : New Target`,\n    content: `<form><div class=\"form-group\"><label for=\"target\">Pick Target</label><select id=\"target\">${targetList}</select></div></form>`,\n    buttons: {\n      attack: {\n        label: \"Attack\",\n        callback: async (html) => {\n          let find_target = html.find('#target').val();\n          let get_target = canvas.tokens.get(find_target);\n          await get_target.setTarget(true, { releaseOthers: true });\n          let roll = actorD.items.get(itemD._id).rollAttack();\n          if (roll.total >= get_target.actor.data.data.attributes.ac.value) {\n            const newCritical = roll.terms[0].total === 20 ? true : false;\n            await dealDamage(get_target, 1, newCritical, itemD);           \n          }\n          resolve();\n        }\n      }\n    },\n    default: \"attack\"\n  }).render(true);\n  });\n  await dialog;\n}\n\nasync function dealDamage(target, reCast, newCritical, itemD) { \n  let numDice = newCritical ? `1d8 + 1d8 + 2d8 + ${upcast * 2}d6` : lastArg.isCritical ? `1d8 + 1d8 + 2d8 + ${upcast * 2}d6` : `1d8 + 1d8 + ${upcast}d6`;\n  let damageRoll = new Roll(`${numDice}`).evaluate({ async: false });\n  let firstElement = damageList[damageRoll.terms[0].total];\n  let secondElement = damageList[damageRoll.terms[2].total];\n  let selectElement;\n  let castAgain = 0;\n  let elementList = [];\n  if (firstElement != secondElement) {\n    elementList.push(firstElement);\n    elementList.push(secondElement);\n    castAgain = 0;\n  } else {\n    elementList = firstElement;\n    castAgain = 1;\n  }\n  for (let element of elementList) {\n    selectElement += `<option value=\"${element}\">${element}</option>`;\n  }\n  if (firstElement === secondElement) {\n    damageRoll.terms[0].options.flavor = elementList;\n    damageRoll.terms[2].options.flavor = elementList;\n    damageRoll.terms[4].options.flavor = elementList;\n    lastArg.isCritical ? damageRoll.terms[6].options.flavor = elementList : \"\";\n    game.dice3d?.showForRoll(damageRoll);\n    if (reCast === 1) {\n      let msgHistory = game.messages.filter(i => i.data.flavor === itemD.name && i.data.speaker.token === tokenD.id);\n      let lastMessage = msgHistory.pop();\n      let newId = lastMessage.data._id;\n      await workflowDamage(damageRoll, elementList, target, newId, itemD);\n    } else {\n      await workflowDamage(damageRoll, elementList, target, lastArg.itemCardId, itemD);      \n    }\n    if (castAgain === 1) {\n      await findTarget(target, itemD);\n    }\n  } else {\n    let the_message = `<form><div class=\"form-group\"><label for=\"element\">Pick Element</label><select id=\"element\">${selectElement}</select></div></form>`;\n    let dialog = new Promise((resolve) => {\n    new Dialog({\n      title: itemD.name,\n      content: the_message,\n      buttons: {\n        damage: {\n          label: \"Damage\",\n          callback: async (html) => {\n            let element = html.find('#element').val();\n            damageRoll.terms[0].options.flavor = element;\n            damageRoll.terms[2].options.flavor = element;\n            damageRoll.terms[4].options.flavor = element;\n            lastArg.isCritical ? damageRoll.terms[6].options.flavor = element : \"\";\n            game.dice3d?.showForRoll(damageRoll);\n            if (reCast === 1) {\n              let msgHistory = game.messages.filter(i => i.data.flavor === itemD.name && i.data.speaker.token === tokenD.id);\n              let lastMessage = msgHistory.pop();\n              let newId = lastMessage.data._id;              \n              await workflowDamage(damageRoll, element, target, newId, itemD);\n            } else {\n              await workflowDamage(damageRoll, element, target, lastArg.itemCardId, itemD);\n            }\n            resolve();\n          }\n        }\n      },\n      default: \"damage\"\n    }).render(true);\n  });\n  await dialog;\n  }\n}\n\nasync function workflowDamage(damageRoll, element, target, cardId, itemD) {  \n  let damageWorkflow = await new MidiQOL.DamageOnlyWorkflow(actorD, tokenD, damageRoll.total, element, [target], damageRoll, { flavor: `(${element})`, itemCardId: cardId, itemData: itemD, useOther: false });\n  let damageBonusMacro = getProperty(actorD.data.flags, `${game.system.id}.DamageBonusMacro`);\n  if (damageBonusMacro) {\n    await damageWorkflow.rollBonusDamage(damageBonusMacro);\n  } else {\n    await damageWorkflow;\n  }\n}",
        "folder": null,
        "sort": 0,
        "permission": {
          "default": 0
        },
        "flags": {}
      }
    },
    "favtab": {
      "isFavorite": true
    },
    "enhanced-terrain-layer": {
      "multiple": 1,
      "min": 0,
      "max": 0,
      "environment": "",
      "elevation": null,
      "depth": null
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "exportSource": {
      "world": "dnd5e",
      "system": "dnd5e",
      "coreVersion": "9.280",
      "systemVersion": "1.6.3"
    },
    "rest-recovery": {
      "data": {
        "recovery": {
          "enabled": false
        }
      }
    },
    "scene-packer": {
      "sourceId": "Item.qd6X1vO65rESBFOo",
      "hash": "bc89780252e3bc852fe92e6b78d738c44ccc1de4"
    }
  }
}
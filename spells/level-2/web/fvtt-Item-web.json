{
  "name": "Web",
  "type": "spell",
  "img": "icons/commodities/materials/material-webbing.webp",
  "data": {
    "description": {
      "value": "<p>You conjure a mass of thick, sticky webbing at a point of your choice within range. The webs fill a 20-foot cube from that point for the duration. The webs are difficult terrain and lightly obscure their area.</p>\n<p>If the webs aren't anchored between two solid masses (such as walls or trees) or layered across a floor, wall, or ceiling, the conjured web collapses on itself, and the spell ends at the start of your next turn. Webs layered over a flat surface have a depth of 5 feet.</p>\n<p>Each creature that starts its turn in the webs or that enters them during its turn must make a Dexterity saving throw. On a failed save, the creature is @Compendium[dnd5e.rules.Restrained]{restrained} as long as it remains in the webs or until it breaks free.</p>\n<p>A creature @Compendium[dnd5e.rules.Restrained]{restrained} by the webs can use its action to make a Strength check against your spell save DC. If it succeeds, it is no longer @Compendium[dnd5e.rules.Restrained]{restrained}.</p>\n<p>The webs are flammable. Any 5-foot cube of webs exposed to fire burns away in 1 round, dealing 2d4 fire damage to any creature that starts its turn in the fire.</p>",
      "chat": "",
      "unidentified": ""
    },
    "source": "Basic Rules, Player's Handbook pg 287",
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": 1,
      "units": "hour"
    },
    "target": {
      "value": 20,
      "width": null,
      "units": "ft",
      "type": "cube"
    },
    "range": {
      "value": 60,
      "long": null,
      "units": "ft"
    },
    "uses": {
      "value": null,
      "max": "",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "other",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": ""
    },
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell"
    },
    "level": 2,
    "school": "con",
    "components": {
      "value": "a bit of spiderweb",
      "vocal": true,
      "somatic": true,
      "material": true,
      "ritual": false,
      "concentration": true
    },
    "materials": {
      "value": "a bit of spiderweb",
      "consumed": false,
      "cost": 0,
      "supply": 0
    },
    "preparation": {
      "mode": "prepared",
      "prepared": false
    },
    "scaling": {
      "mode": "none",
      "formula": ""
    },
    "attunement": 0
  },
  "effects": [
    {
      "label": "Web",
      "icon": "icons/commodities/materials/material-webbing.webp",
      "changes": [
        {
          "key": "macro.itemMacro",
          "value": "@item.level @attributes.spelldc",
          "mode": 0,
          "priority": 20
        }
      ],
      "duration": {
        "seconds": 3600,
        "startTime": null
      },
      "tint": null,
      "transfer": false,
      "disabled": false,
      "flags": {
        "dae": {
          "transfer": false,
          "stackable": "none",
          "macroRepeat": "startEveryTurn"
        },
        "ddbimporter": {
          "disabled": false
        },
        "midi-qol": {
          "forceCEOff": true
        },
        "ActiveAuras": {
          "isAura": true,
          "aura": "All",
          "radius": null,
          "alignment": "",
          "type": "",
          "ignoreSelf": false,
          "height": false,
          "hidden": false,
          "onlyOnce": false,
          "save": "dex",
          "savedc": null,
          "displayTemp": true
        }
      },
      "_id": "6nocpra41zok9zvu"
    }
  ],
  "flags": {
    "ddbimporter": {
      "id": 138944,
      "definitionId": 2299,
      "entityTypeId": 435869154,
      "dndbeyond": {
        "lookup": "generic",
        "lookupName": "generic",
        "level": null,
        "castAtLevel": null
      },
      "originalName": "Web",
      "sources": [
        {
          "sourceId": 1,
          "pageNumber": null,
          "sourceType": 2
        },
        {
          "sourceId": 2,
          "pageNumber": 287,
          "sourceType": 1
        }
      ],
      "tags": [
        "Control"
      ],
      "version": "2.9.59",
      "effectsApplied": true,
      "effect": {
        "applyStart": true,
        "applyEntry": true,
        "applyImmediate": false,
        "everyEntry": false,
        "allowVsRemoveCondition": true,
        "removalCheck": "str",
        "removalSave": null,
        "saveRemoves": false,
        "condition": "Restrained",
        "save": "dex"
      }
    },
    "betterRolls5e": {
      "quickVersatile": {
        "altValue": true
      },
      "quickCharges": {
        "value": {
          "use": true,
          "resource": true
        },
        "altValue": {
          "use": true,
          "resource": true
        }
      }
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Web",
          "type": "script",
          "author": "otqBqyqMuTGDffTr",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "// web\n// effect still doesn't apply to item parent\n\nif(!game.modules.get(\"ActiveAuras\")?.active) {\n    ui.notifications.error(\"ActiveAuras is not enabled\");\n    return;\n  }\n  \n  const lastArg = args[args.length - 1];\n  \n  async function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\n  \n  async function attemptRemoval(targetToken, condition, item) {\n    if (game.dfreds.effectInterface.hasEffectApplied(condition, targetToken.uuid)) {\n      new Dialog({\n        title: `Use action to attempt to remove ${condition}?`,\n        buttons: {\n          one: {\n            label: \"Yes\",\n            callback: async () => {\n              const caster = item.parent;\n              const saveDc = caster.data.data.attributes.spelldc;\n              const removalCheck = \"str\";\n              const removalSave = null;\n              const ability = removalCheck ? removalCheck : removalSave;\n              const type = removalCheck ? \"check\" : \"save\";\n              const flavor = `${condition} (via ${item.name}) : ${CONFIG.DND5E.abilities[ability]} ${type} vs DC${saveDc}`;\n              const rollResult = removalCheck\n                ? (await targetToken.actor.rollAbilityTest(ability, { flavor })).total\n                : (await targetToken.actor.rollAbilitySave(ability, { flavor })).total;\n  \n              if (rollResult >= saveDc) {\n                game.dfreds.effectInterface.removeEffect({ effectName: \"Restrained\", uuid: targetToken.uuid });\n              } else {\n                if (rollResult < saveDc) ChatMessage.create({ content: `${targetToken.name} fails the ${type} for ${item.name}, still has the ${condition} condition.` });\n              }\n            },\n          },\n          two: {\n            label: \"No\",\n            callback: () => {},\n          },\n        },\n      }).render(true);\n    }\n  }\n  \n  async function applyCondition(condition, targetToken, item, itemLevel) {\n    if (!game.dfreds.effectInterface.hasEffectApplied(condition, targetToken.uuid)) {\n      const caster = item.parent;\n      const workflowItemData = duplicate(item.data);\n      workflowItemData.data.target = { value: 1, units: \"\", type: \"creature\" };\n      workflowItemData.data.save.ability = \"dex\";\n      workflowItemData.data.components.concentration = false;\n      workflowItemData.data.level = itemLevel;\n      workflowItemData.data.duration = { value: null, units: \"inst\" };\n      workflowItemData.data.target = { value: null, width: null, units: \"\", type: \"creature\" };\n      workflowItemData.data.preparation.mode = \"atwill\";\n      setProperty(workflowItemData, \"flags.itemacro\", {});\n      setProperty(workflowItemData, \"flags.midi-qol\", {});\n      setProperty(workflowItemData, \"flags.dae\", {});\n      setProperty(workflowItemData, \"effects\", []);\n      delete workflowItemData._id;\n      workflowItemData.name = `${workflowItemData.name}: ${item.name} Condition save`;\n      // console.warn(\"workflowItemData\", workflowItemData);\n  \n      const saveTargets = [...game.user?.targets].map((t) => t.id ?? t._id);\n      const targetTokenId = targetToken.id ?? targetToken._id;\n      game.user.updateTokenTargets([targetTokenId]);\n      const saveItem = new CONFIG.Item.documentClass(workflowItemData, { parent: caster });\n      const options = { showFullCard: false, createWorkflow: true, configureDialog: true };\n      const result = await MidiQOL.completeItemRoll(saveItem, options);\n  \n      game.user.updateTokenTargets(saveTargets);\n      const failedSaves = [...result.failedSaves];\n      if (failedSaves.length > 0) {\n        await game.dfreds.effectInterface.addEffect({ effectName: \"Restrained\", uuid: failedSaves[0].document.uuid });\n      }\n  \n      return result;\n    }\n  }\n  \n  if (args[0].tag === \"OnUse\" && args[0].macroPass === \"preActiveEffects\") {\n    const safeName = lastArg.itemData.name.replace(/\\s|'|\\.|’/g, \"_\");\n    const dataTracker = {\n      randomId: randomID(),\n      targetUuids: lastArg.targetUuids,\n      startRound: game.combat.round,\n      startTurn: game.combat.turn,\n      spellLevel: lastArg.spellLevel,\n    };\n  \n    const item = await fromUuid(lastArg.itemUuid);\n    // await item.update(dataTracker);\n    await DAE.unsetFlag(item, `${safeName}Tracker`);\n    await DAE.setFlag(item, `${safeName}Tracker`, dataTracker);\n  \n  \n    return await AAhelpers.applyTemplate(args);\n  \n  } else if (args[0] == \"on\" || args[0] == \"each\") {\n    const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n    const item = await fromUuid(lastArg.efData.origin);\n    // sometimes the round info has not updated, so we pause a bit\n    if (args[0] == \"each\") await wait(500);\n    const targetItemTracker = DAE.getFlag(item.parent, `${safeName}Tracker`);\n    const originalTarget = targetItemTracker.targetUuids.includes(lastArg.tokenUuid);\n    const target = await fromUuid(lastArg.tokenUuid);\n    const targetTokenTrackerFlag = DAE.getFlag(target, `${safeName}Tracker`);\n    const targetedThisCombat = targetTokenTrackerFlag && targetItemTracker.randomId === targetTokenTrackerFlag.randomId;\n    const targetTokenTracker = targetedThisCombat\n      ? targetTokenTrackerFlag\n      : {\n        randomId: targetItemTracker.randomId,\n        round: game.combat.round,\n        turn: game.combat.turn,\n        hasLeft: false,\n        condition: \"Restrained\",\n      };\n  \n    const castTurn = targetItemTracker.startRound === game.combat.round && targetItemTracker.startTurn === game.combat.turn;\n    const isLaterTurn = game.combat.round > targetTokenTracker.round || game.combat.turn > targetTokenTracker.turn;\n    const everyEntry = false;\n  \n    // if:\n    // not cast turn, and not part of the original target\n    // AND one of the following\n    // not original template and have not yet had this effect applied this combat OR\n    // has been targeted this combat, left and re-entered effect, and is a later turn\n  \n    if (castTurn && originalTarget) {\n      console.debug(`Token ${target.name} is part of the original target for ${item.name}`);\n    } else if (everyEntry || !targetedThisCombat || (targetedThisCombat && isLaterTurn)) {\n      console.debug(`Token ${target.name} is targeted for immediate save vs condition with ${item.name}, using the following factors`, { originalTarget, castTurn, targetedThisCombat, targetTokenTracker, isLaterTurn });\n      targetTokenTracker.hasLeft = false;\n      await applyCondition(targetTokenTracker.condition, target, item, targetItemTracker.spellLevel);\n    }\n    await DAE.setFlag(target, `${safeName}Tracker`, targetTokenTracker);\n    const allowVsRemoveCondition = true;\n    const effectApplied = game.dfreds.effectInterface.hasEffectApplied(targetTokenTracker.condition, target.uuid);\n    const currentTokenCombatTurn = game.combat.current.tokenId === lastArg.tokenId;\n    if (currentTokenCombatTurn && allowVsRemoveCondition && effectApplied) {\n      console.warn(`Removing ${targetTokenTracker.condition}`);\n      await attemptRemoval(target, targetTokenTracker.condition, item);\n    }\n  } else if (args[0] == \"off\") {\n    const safeName = lastArg.efData.label.replace(/\\s|'|\\.|’/g, \"_\");\n    const targetToken = await fromUuid(lastArg.tokenUuid);\n    const targetTokenTracker = await DAE.getFlag(targetToken, `${safeName}Tracker`);\n    const removeOnOff = true;\n  \n    if (targetTokenTracker?.condition && removeOnOff && game.dfreds.effectInterface.hasEffectApplied(targetTokenTracker.condition, lastArg.tokenUuid)) {\n      console.debug(`Removing ${targetTokenTracker.condition} from ${targetToken.name}`);\n      game.dfreds.effectInterface.removeEffect({ effectName: \"Restrained\", uuid: lastArg.tokenUuid });\n    }\n  \n    if (targetTokenTracker) {\n      targetTokenTracker.hasLeft = true;\n      targetTokenTracker.turn = game.combat.turn;\n      targetTokenTracker.round = game.combat.round;\n      await DAE.setFlag(targetToken, `${safeName}Tracker`, targetTokenTracker);\n    }\n  }",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        }
      }
    },
    "midi-qol": {
      "onUseMacroName": "[preActiveEffects]ItemMacro",
      "effectActivation": false
    },
    "rest-recovery": {
      "data": {
        "recovery": {
          "enabled": false
        }
      }
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "core": {
      "sourceId": "Compendium.world.ddb-spells.C5NtYn4b6KAt5sMh"
    },
    "scene-packer": {
      "sourceId": "Item.aWEobXzloudfurQ4",
      "hash": "89ff5e8a0d37e29b0c09d0d7d98fef84a6938e83"
    },
    "exportSource": {
      "world": "Curse of Strahd",
      "system": "dnd5e",
      "coreVersion": "9.280",
      "systemVersion": "1.6.3"
    }
  }
}